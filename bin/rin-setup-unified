#!/usr/bin/env bash
#
# rin-setup-unified - Unified setup system for Rinna
#
# PURPOSE: Single entry point for all Rinna environment setup, dependency management,
#          and configuration tasks. Consolidates functionality of setup-python.sh,
#          rin-setup, and install-rinna.sh.
#
# Copyright (c) 2025 Eric C. Mumford (@heymumford)
# This file is subject to the terms and conditions defined in
# the LICENSE file, which is part of this source code package.
# (MIT License)
#

set -eo pipefail

# Debug mode for troubleshooting
DEBUG=true

# Add debug function
debug_echo() {
  if [[ "$DEBUG" == "true" ]]; then
    echo "DEBUG: $*" >&2
  fi
}

# Function to create minimal utilities file
create_minimal_utilities() {
  debug_echo "Creating minimal rinna_utils.sh file"
  
  cat > "$COMMON_DIR/rinna_utils.sh" << 'EOF'
#!/usr/bin/env bash
#
# rinna_utils.sh - Common utility functions for Rinna shell scripts
#
# PURPOSE: Provide shared functions for all Rinna utility scripts
#          to ensure consistent behavior and reduce code duplication
#
# Copyright (c) 2025 Eric C. Mumford (@heymumford)
# This file is subject to the terms and conditions defined in
# the LICENSE file, which is part of this source code package.
# (MIT License)
#

# Ensure we fail on errors
set -eo pipefail

# Determine project directory
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
RINNA_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Constants
VERSION_FILE="$RINNA_DIR/version.properties"
LOG_DIR="$RINNA_DIR/logs"
DEFAULT_LOG_FILE="$LOG_DIR/rinna.log"

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Create log directory
mkdir -p "$LOG_DIR"

# UI functions - minimal set
print_header() { echo -e "${BLUE}${BOLD}$1${NC}"; }
print_success() { echo -e "${GREEN}✓ $1${NC}"; }
print_warning() { echo -e "${YELLOW}! $1${NC}"; }
print_error() { echo -e "${RED}✗ $1${NC}" >&2; }
print_debug() { [[ "${VERBOSE:-$DEBUG}" == "true" ]] && echo -e "${GRAY}DEBUG: $1${NC}"; }
print_step() { echo -e "  ${MAGENTA}→ $1${NC}"; }

# Check if command exists
command_exists() {
  command -v "$1" &> /dev/null
}

# Get Rinna version
get_version() {
  if [ ! -f "$VERSION_FILE" ]; then
    echo "unknown"
    return 1
  fi
  
  local version
  version=$(grep -m 1 "^version=" "$VERSION_FILE" 2>/dev/null | cut -d'=' -f2)
  
  if [[ -z "$version" ]]; then
    echo "unknown"
    return 1
  fi
  
  echo "$version"
  return 0
}

# Detect if running in CI environment
is_ci() {
  if [[ -n "${CI:-}" || -n "${GITHUB_ACTIONS:-}" || -n "${GITLAB_CI:-}" || -n "${JENKINS_URL:-}" || -n "${TRAVIS:-}" ]]; then
    echo "true"
  else
    echo "false"
  fi
}
EOF

  # Make the file executable
  chmod +x "$COMMON_DIR/rinna_utils.sh"
  debug_echo "Created minimal rinna_utils.sh file"
}

debug_echo "Starting setup script"

# Determine script and project directories
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
RINNA_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_DIR="$HOME/.config/rinna"
CONFIG_FILE="$CONFIG_DIR/environment.conf"
COMMON_DIR="$SCRIPT_DIR/common"

debug_echo "SCRIPT_PATH=$SCRIPT_PATH"
debug_echo "SCRIPT_DIR=$SCRIPT_DIR"
debug_echo "RINNA_DIR=$RINNA_DIR"
debug_echo "CONFIG_DIR=$CONFIG_DIR"
debug_echo "COMMON_DIR=$COMMON_DIR"

# Source common utilities
debug_echo "About to source common utilities from $COMMON_DIR/rinna_utils.sh"
# Export DEBUG and VERBOSE to be available to sourced scripts
export DEBUG VERBOSE
# Check if the file exists before sourcing
if [[ -f "$COMMON_DIR/rinna_utils.sh" ]]; then
    source "$COMMON_DIR/rinna_utils.sh"
    debug_echo "Successfully sourced common utilities"
else
    echo -e "\033[0;31m✗ Error: Common utilities file not found: $COMMON_DIR/rinna_utils.sh\033[0m" >&2
    echo "Creating directory structure..."
    mkdir -p "$COMMON_DIR"
    
    # Create minimal rinna_utils.sh to get started
    create_minimal_utilities
    
    # Try sourcing again
    if [[ -f "$COMMON_DIR/rinna_utils.sh" ]]; then
        source "$COMMON_DIR/rinna_utils.sh"
        debug_echo "Successfully sourced minimal common utilities"
    else
        echo -e "\033[0;31m✗ Fatal error: Could not create utilities file\033[0m" >&2
        exit 1
    fi
fi

# Required versions
REQUIRED_JAVA_VERSION="21"
REQUIRED_GO_VERSION="1.21"
REQUIRED_PYTHON_VERSION="3.8"
REQUIRED_MAVEN_VERSION="3.8"

# State variables
INSTALL_MISSING="ask"  # Options: ask, auto, never
MODE="standard"        # Options: standard, graphical, fast, minimal
VERBOSE="false"
FORCE="false"
BACKUP="true"
INTERACTIVE="true"
SKIP_TESTS="false"
SKIP_SYSTEM="false"
PYTHON_INSTALL_OPTIONAL="false"
COMPONENTS=()

# Check if running in a CI environment
if [[ "$(is_ci)" == "true" ]]; then
  # Default to non-interactive mode in CI
  INTERACTIVE="false"
  INSTALL_MISSING="auto"
  MODE="fast"
fi

# Parse command line arguments
parse_args() {
  debug_echo "Parsing command line arguments: $*"
  local arg
  
  # Check if no arguments were provided
  if [[ $# -eq 0 ]]; then
    debug_echo "No arguments provided, using defaults"
  fi
  
  while [[ $# -gt 0 ]]; do
    arg="$1"
    debug_echo "Processing argument: $arg"
    
    # Handle standalone config component specially
    if [[ "$arg" == "config" && "$#" -eq 1 ]]; then
      debug_echo "Detected standalone config component"
      COMPONENTS=("config")
      shift
      continue
    fi
    
    case "$arg" in
      install|--install)
        INSTALL_MISSING="auto"
        debug_echo "Set INSTALL_MISSING=auto"
        shift
        ;;
      check|--check)
        INSTALL_MISSING="never"
        debug_echo "Set INSTALL_MISSING=never"
        shift
        ;;
      config)
        # This is a component name, not a command mode
        COMPONENTS+=("$1")
        debug_echo "Added component: $1"
        shift
        ;;
      --config)
        debug_echo "Config mode selected, will edit configuration"
        # Edit config mode - interactive
        edit_config
        exit 0
        ;;
      --graphical)
        MODE="graphical"
        debug_echo "Set MODE=graphical"
        shift
        ;;
      --fast)
        MODE="fast"
        debug_echo "Set MODE=fast"
        shift
        ;;
      --minimal)
        MODE="minimal"
        debug_echo "Set MODE=minimal"
        shift
        ;;
      -v|--verbose)
        VERBOSE="true"
        export VERBOSE
        debug_echo "Set VERBOSE=true"
        
        # Only set log level if function exists
        if command -v set_log_level &>/dev/null; then
          set_log_level "debug"
          debug_echo "Set log level to debug"
        else
          debug_echo "set_log_level function not available yet"
        fi
        
        shift
        ;;
      -f|--force)
        FORCE="true"
        debug_echo "Set FORCE=true"
        shift
        ;;
      -y|--yes)
        INTERACTIVE="false"
        debug_echo "Set INTERACTIVE=false"
        shift
        ;;
      --no-backup)
        BACKUP="false"
        debug_echo "Set BACKUP=false"
        shift
        ;;
      --skip-tests)
        SKIP_TESTS="true"
        debug_echo "Set SKIP_TESTS=true"
        shift
        ;;
      --skip-system)
        SKIP_SYSTEM="true"
        debug_echo "Set SKIP_SYSTEM=true"
        shift
        ;;
      --all|--optional)
        PYTHON_INSTALL_OPTIONAL="true"
        debug_echo "Set PYTHON_INSTALL_OPTIONAL=true"
        shift
        ;;
      java|go|python|maven|ui|api|venv|samples)
        COMPONENTS+=("$1")
        debug_echo "Added component: $1"
        shift
        ;;
      help|--help|-h)
        debug_echo "Help requested"
        show_help
        exit 0
        ;;
      standard)
        # We can safely ignore this as it's the default mode
        debug_echo "Standard mode explicitly specified (redundant)"
        shift
        ;;
      *)
        echo -e "\033[0;31m✗ Unknown option: $arg\033[0m" >&2
        show_help
        exit 1
        ;;
    esac
  done
  
  # If no components specified, include all
  if [[ ${#COMPONENTS[@]} -eq 0 ]]; then
    debug_echo "No components specified, using defaults"
    COMPONENTS=("java" "go" "python" "maven" "config")
    
    # Add venv for full setup
    if [[ "$MODE" != "minimal" ]]; then
      COMPONENTS+=("venv" "ui")
      debug_echo "Added venv and ui components for non-minimal setup"
    fi
  fi
  
  debug_echo "Final components: ${COMPONENTS[*]}"
  debug_echo "Setup mode: $MODE"
}

# Display help text
show_help() {
  cat << EOF
${BLUE}${BOLD}rin-setup-unified${NC} - Unified setup system for Rinna

This script provides a single entry point for all Rinna environment setup,
dependency management, and configuration tasks.

Usage: rin-setup-unified [modes] [options] [components]

Modes:
  install             Install missing dependencies without prompting
  check               Check for missing dependencies without installing
  config              Create or edit the configuration file

Options:
  -v, --verbose       Enable verbose output
  -f, --force         Force reinstallation/recreation of components
  -y, --yes           Non-interactive mode (answer yes to all prompts)
  --graphical         Use graphical installer mode
  --fast              Use fast setup mode (minimal output)
  --minimal           Minimal setup (core components only)
  --no-backup         Skip creating backups
  --skip-tests        Skip running tests
  --skip-system       Skip system package installation
  --all, --optional   Install optional dependencies (for Python)

Components:
  java                Java environment setup
  go                  Go environment setup
  python              Python environment setup
  maven               Maven build system setup
  ui                  UI components and configuration
  api                 API service setup
  config              Configuration files and environment
  venv                Python virtual environment
  samples             Java sample projects with Clean Architecture

Examples:
  rin-setup-unified                  # Full setup with all components
  rin-setup-unified install          # Install all components without prompting
  rin-setup-unified --graphical      # Run the graphical installer
  rin-setup-unified -f python venv   # Force reinstall Python environment
  rin-setup-unified --minimal        # Minimal setup for core functionality
  rin-setup-unified --fast api go    # Fast setup of API and Go components

Configuration:
  The script uses $CONFIG_FILE for persistent configuration.
  This can be edited directly with the 'config' command.
EOF
}

# Logo and branding
print_logo() {
  clear
  echo -e "${BLUE}"
  echo "        ____  _"
  echo "       / __ \\(_)___  ____  ____ _"
  echo "      / /_/ / / __ \\/ __ \\/ __ \`/"
  echo "     / _, _/ / / / / / / / /_/ /"
  echo "    /_/ |_/_/_/ /_/_/ /_/\\__,_/"
  echo -e "${NC}"
  echo "    Workflow Management System"
  echo "    Setup & Configuration Tool"
  echo ""
}

# Create or update config file
create_config() {
  mkdir -p "$CONFIG_DIR"
  
  cat > "$CONFIG_FILE" << EOF
# Rinna Environment Configuration
# Generated on $(date)
# This file is automatically managed by rin-setup-unified

# Language versions
JAVA_VERSION="$REQUIRED_JAVA_VERSION"
GO_VERSION="$REQUIRED_GO_VERSION"
PYTHON_VERSION="$REQUIRED_PYTHON_VERSION"
MAVEN_VERSION="$REQUIRED_MAVEN_VERSION"

# Path overrides (uncomment and set if needed)
# JAVA_HOME="/path/to/java"
# GOROOT="/path/to/go"
# GOPATH="$HOME/go"
# PYTHON_PATH="/path/to/python"

# Proxy settings (uncomment and set if needed)
# HTTP_PROXY=""
# HTTPS_PROXY=""
# NO_PROXY="localhost,127.0.0.1"

# Package manager preferences
# Preferred package manager for dependency installation
# Options: apt, apt-get, dnf, yum, brew, pkg, auto
PACKAGE_MANAGER="auto"

# Auto-update settings
# Set to true to automatically check for and install updates to dependencies
AUTO_UPDATE="false"

# Install options
# Set to ask (default), auto, or never
INSTALL_MISSING="ask"

# Setup preferences
# Component settings and flags
ENABLE_GRAPHICAL_INSTALLER="true"
PREFER_FAST_MODE="false"
SKIP_TESTS="false"
VERBOSE_OUTPUT="false"
EOF

  chmod 600 "$CONFIG_FILE"
  print_success "Configuration file created at $CONFIG_FILE"
}

# Load config if exists, otherwise create it
load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    print_subheader "Creating configuration file..."
    create_config
  fi
  
  # Source the config file
  source "$CONFIG_FILE"
  
  # Use environment variables if provided, otherwise use config values
  REQUIRED_JAVA_VERSION="${JAVA_VERSION:-$REQUIRED_JAVA_VERSION}"
  REQUIRED_GO_VERSION="${GO_VERSION:-$REQUIRED_GO_VERSION}"
  REQUIRED_PYTHON_VERSION="${PYTHON_VERSION:-$REQUIRED_PYTHON_VERSION}"
  
  # Handle auto package manager detection
  if [[ "$PACKAGE_MANAGER" == "auto" || -z "$PACKAGE_MANAGER" ]]; then
    detect_package_manager
  fi
}

# Detect the appropriate package manager for this system
detect_package_manager() {
  if [[ "$(uname)" == "Darwin" ]]; then
    # macOS
    if command_exists brew; then
      PACKAGE_MANAGER="brew"
    else
      PACKAGE_MANAGER="brew"
      print_warning "Homebrew not found but set as default. Will attempt to install if needed."
    fi
  elif [[ "$(uname)" == "Linux" ]]; then
    # Linux
    if command_exists apt; then
      PACKAGE_MANAGER="apt"
    elif command_exists apt-get; then
      PACKAGE_MANAGER="apt-get"
    elif command_exists dnf; then
      PACKAGE_MANAGER="dnf"
    elif command_exists yum; then
      PACKAGE_MANAGER="yum"
    else
      print_warning "Could not detect package manager. Please install dependencies manually."
      PACKAGE_MANAGER="unknown"
    fi
  elif [[ "$(uname)" == "FreeBSD" ]]; then
    # FreeBSD
    PACKAGE_MANAGER="pkg"
  else
    print_warning "Unsupported operating system: $(uname)"
    PACKAGE_MANAGER="unknown"
  fi
  
  log "info" "Using package manager: $PACKAGE_MANAGER"
}

# Ask user for confirmation
confirm() {
  local prompt="$1"
  local default="${2:-Y}"
  
  if [[ "$INTERACTIVE" == "false" ]]; then
    return 0
  elif [[ "$INSTALL_MISSING" == "never" ]]; then
    return 1
  fi
  
  local options
  if [[ "$default" == "Y" ]]; then
    options="[Y/n]"
  else
    options="[y/N]"
  fi
  
  read -p "$prompt $options " answer
  answer=${answer:-$default}
  
  if [[ "$answer" =~ ^[Yy]$ ]]; then
    return 0
  else
    return 1
  fi
}

# Install packages based on the detected package manager
install_packages() {
  local packages=("$@")
  
  if [[ "$SKIP_SYSTEM" == "true" ]]; then
    print_warning "Skipping system package installation due to --skip-system flag"
    return 0
  fi
  
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      # Ubuntu/Debian
      log "info" "Updating package index..."
      sudo $PACKAGE_MANAGER update -q
      log "info" "Installing packages: ${packages[*]}"
      sudo $PACKAGE_MANAGER install -y "${packages[@]}"
      ;;
    dnf|yum)
      # Fedora/RHEL/CentOS
      log "info" "Installing packages: ${packages[*]}"
      sudo $PACKAGE_MANAGER install -y "${packages[@]}"
      ;;
    brew)
      # macOS (Homebrew)
      if ! command_exists brew; then
        log "info" "Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
      fi
      log "info" "Installing packages: ${packages[*]}"
      brew install "${packages[@]}"
      ;;
    pkg)
      # FreeBSD
      log "info" "Installing packages: ${packages[*]}"
      sudo pkg install -y "${packages[@]}"
      ;;
    *)
      print_error "Unsupported package manager: $PACKAGE_MANAGER"
      return 1
      ;;
  esac
  
  return 0
}

# Add third-party repository
add_repo() {
  local repo="$1"
  local repo_name="${2:-$1}"
  
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      if ! grep -q "^deb.*$repo" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null; then
        log "info" "Adding repository: $repo_name"
        sudo add-apt-repository -y "$repo"
        sudo $PACKAGE_MANAGER update -q
      fi
      ;;
    dnf|yum)
      log "info" "Adding repository: $repo_name"
      sudo $PACKAGE_MANAGER config-manager --add-repo "$repo"
      ;;
    *)
      print_warning "Repository management not supported for $PACKAGE_MANAGER"
      ;;
  esac
}

# Edit config file with default editor or dedicated tool
edit_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    create_config
  fi
  
  # Check if we have the dedicated config tool
  if [[ -x "$SCRIPT_DIR/rin-config" ]]; then
    "$SCRIPT_DIR/rin-config" "view"
    print_subheader "To edit configuration values, use:"
    print_subheader "  $SCRIPT_DIR/rin-config set <key> <value>"
    
    if confirm "Would you like to create user-specific config file for this environment?"; then
      "$SCRIPT_DIR/rin-config" "create-user" "$CURRENT_ENV"
    fi
    
    return 0
  else
    # Fall back to basic editor
    if [[ -n "$EDITOR" ]]; then
      $EDITOR "$CONFIG_FILE"
    elif command_exists nano; then
      nano "$CONFIG_FILE"
    elif command_exists vim; then
      vim "$CONFIG_FILE"
    else
      print_error "No text editor found. Please edit $CONFIG_FILE manually."
    fi
    
    return 0
  fi
}

#
# Component-specific installation functions
#

# Setup Java sample projects
setup_java_samples() {
  print_header "Setting up Java sample projects..."
  
  # Check if Java is already installed
  if ! check_java_version "$REQUIRED_JAVA_VERSION"; then
    print_error "Java $REQUIRED_JAVA_VERSION is required for sample projects"
    print_step "Please run 'bin/rin-setup-unified java' first"
    return 1
  fi
  
  # Create sample project directory
  local samples_dir="$RINNA_DIR/samples"
  mkdir -p "$samples_dir"
  
  # Check if we already have samples
  if [[ -d "$samples_dir/hello-rinna" ]]; then
    print_success "Sample projects already exist"
    return 0
  fi
  
  # Create a simple hello world project
  local hello_dir="$samples_dir/hello-rinna"
  mkdir -p "$hello_dir/src/main/java/org/rinna/samples"
  mkdir -p "$hello_dir/src/test/java/org/rinna/samples"
  
  # Create pom.xml
  cat > "$hello_dir/pom.xml" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.rinna.samples</groupId>
    <artifactId>hello-rinna</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>${REQUIRED_JAVA_VERSION}</maven.compiler.source>
        <maven.compiler.target>${REQUIRED_JAVA_VERSION}</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <junit.version>5.9.1</junit.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>\${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>\${junit.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.0.0</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <mainClass>org.rinna.samples.HelloRinna</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
EOF

  # Create main class
  cat > "$hello_dir/src/main/java/org/rinna/samples/HelloRinna.java" << 'EOF'
package org.rinna.samples;

/**
 * A simple Hello Rinna application
 */
public class HelloRinna {
    public static void main(String[] args) {
        System.out.println(getGreeting());
    }

    public static String getGreeting() {
        return "Hello, Rinna!";
    }
}
EOF

  # Create test class
  cat > "$hello_dir/src/test/java/org/rinna/samples/HelloRinnaTest.java" << 'EOF'
package org.rinna.samples;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class HelloRinnaTest {
    @Test
    void testGetGreeting() {
        assertEquals("Hello, Rinna!", HelloRinna.getGreeting());
    }
}
EOF

  print_success "Created sample project at $hello_dir"
  
  # Create a more complex sample using Clean Architecture patterns
  local clean_dir="$samples_dir/clean-arch-demo"
  debug_echo "Creating clean architecture demo directories"
  mkdir -p "$clean_dir/src/main/java/org/rinna/samples/clean/domain/entity"
  mkdir -p "$clean_dir/src/main/java/org/rinna/samples/clean/domain/usecase"
  mkdir -p "$clean_dir/src/main/java/org/rinna/samples/clean/adapter/persistence"
  mkdir -p "$clean_dir/src/main/java/org/rinna/samples/clean/adapter/ui"
  mkdir -p "$clean_dir/src/test/java/org/rinna/samples/clean/domain/usecase"
  
  # Create pom.xml
  cat > "$clean_dir/pom.xml" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.rinna.samples</groupId>
    <artifactId>clean-arch-demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>${REQUIRED_JAVA_VERSION}</maven.compiler.source>
        <maven.compiler.target>${REQUIRED_JAVA_VERSION}</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <junit.version>5.9.1</junit.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>\${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>\${junit.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.0.0</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <mainClass>org.rinna.samples.clean.adapter.ui.ConsoleApp</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
EOF

  # Create main files
  cat > "$clean_dir/src/main/java/org/rinna/samples/clean/domain/entity/Task.java" << 'EOF'
package org.rinna.samples.clean.domain.entity;

import java.time.LocalDateTime;

/**
 * Task entity - core domain model
 */
public class Task {
    private final String id;
    private String title;
    private String description;
    private boolean completed;
    private final LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public Task(String id, String title, String description) {
        this.id = id;
        this.title = title;
        this.description = description;
        this.completed = false;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = this.createdAt;
    }

    public String getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
        this.updatedAt = LocalDateTime.now();
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
        this.updatedAt = LocalDateTime.now();
    }

    public boolean isCompleted() {
        return completed;
    }

    public void setCompleted(boolean completed) {
        this.completed = completed;
        this.updatedAt = LocalDateTime.now();
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    @Override
    public String toString() {
        return "Task{" +
                "id='" + id + '\'' +
                ", title='" + title + '\'' +
                ", completed=" + completed +
                '}';
    }
}
EOF

  cat > "$clean_dir/src/main/java/org/rinna/samples/clean/domain/usecase/TaskRepository.java" << 'EOF'
package org.rinna.samples.clean.domain.usecase;

import org.rinna.samples.clean.domain.entity.Task;

import java.util.List;
import java.util.Optional;

/**
 * Repository interface for Tasks - part of the domain boundary
 */
public interface TaskRepository {
    Task save(Task task);
    Optional<Task> findById(String id);
    List<Task> findAll();
    void delete(String id);
}
EOF

  cat > "$clean_dir/src/main/java/org/rinna/samples/clean/domain/usecase/TaskService.java" << 'EOF'
package org.rinna.samples.clean.domain.usecase;

import org.rinna.samples.clean.domain.entity.Task;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Task service - implements use cases for the domain
 */
public class TaskService {
    private final TaskRepository taskRepository;

    public TaskService(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }

    public Task createTask(String title, String description) {
        Task task = new Task(UUID.randomUUID().toString(), title, description);
        return taskRepository.save(task);
    }

    public Optional<Task> getTaskById(String id) {
        return taskRepository.findById(id);
    }

    public List<Task> getAllTasks() {
        return taskRepository.findAll();
    }

    public Optional<Task> completeTask(String id) {
        return taskRepository.findById(id)
                .map(task -> {
                    task.setCompleted(true);
                    return taskRepository.save(task);
                });
    }

    public void deleteTask(String id) {
        taskRepository.delete(id);
    }
}
EOF

  cat > "$clean_dir/src/main/java/org/rinna/samples/clean/adapter/persistence/InMemoryTaskRepository.java" << 'EOF'
package org.rinna.samples.clean.adapter.persistence;

import org.rinna.samples.clean.domain.entity.Task;
import org.rinna.samples.clean.domain.usecase.TaskRepository;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * In-memory implementation of the task repository
 */
public class InMemoryTaskRepository implements TaskRepository {
    private final Map<String, Task> tasks = new ConcurrentHashMap<>();

    @Override
    public Task save(Task task) {
        tasks.put(task.getId(), task);
        return task;
    }

    @Override
    public Optional<Task> findById(String id) {
        return Optional.ofNullable(tasks.get(id));
    }

    @Override
    public List<Task> findAll() {
        return new ArrayList<>(tasks.values());
    }

    @Override
    public void delete(String id) {
        tasks.remove(id);
    }
}
EOF

  cat > "$clean_dir/src/main/java/org/rinna/samples/clean/adapter/ui/ConsoleApp.java" << 'EOF'
package org.rinna.samples.clean.adapter.ui;

import org.rinna.samples.clean.adapter.persistence.InMemoryTaskRepository;
import org.rinna.samples.clean.domain.entity.Task;
import org.rinna.samples.clean.domain.usecase.TaskRepository;
import org.rinna.samples.clean.domain.usecase.TaskService;

import java.util.List;
import java.util.Optional;
import java.util.Scanner;

/**
 * Console UI implementation for the task management app
 */
public class ConsoleApp {
    private final TaskService taskService;
    private final Scanner scanner;

    public ConsoleApp(TaskService taskService) {
        this.taskService = taskService;
        this.scanner = new Scanner(System.in);
    }

    public static void main(String[] args) {
        TaskRepository repository = new InMemoryTaskRepository();
        TaskService service = new TaskService(repository);
        ConsoleApp app = new ConsoleApp(service);
        
        // Add sample data
        service.createTask("Learn Clean Architecture", "Study the principles of Clean Architecture");
        service.createTask("Implement Rinna App", "Create a workflow management application");
        
        app.run();
    }

    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            int choice = readIntInput();
            
            switch (choice) {
                case 1:
                    listTasks();
                    break;
                case 2:
                    addTask();
                    break;
                case 3:
                    completeTask();
                    break;
                case 4:
                    deleteTask();
                    break;
                case 5:
                    running = false;
                    break;
                default:
                    System.out.println("Invalid option. Please try again.");
            }
        }
        
        System.out.println("Goodbye!");
    }
    
    private void displayMenu() {
        System.out.println("\n--- Task Manager ---");
        System.out.println("1. List all tasks");
        System.out.println("2. Add new task");
        System.out.println("3. Mark task as completed");
        System.out.println("4. Delete task");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }
    
    private void listTasks() {
        List<Task> tasks = taskService.getAllTasks();
        
        if (tasks.isEmpty()) {
            System.out.println("No tasks found.");
            return;
        }
        
        System.out.println("\nTasks:");
        for (Task task : tasks) {
            System.out.printf("%s - %s [%s]%n", 
                    task.getId(), 
                    task.getTitle(),
                    task.isCompleted() ? "Completed" : "Pending");
        }
    }
    
    private void addTask() {
        System.out.print("Enter task title: ");
        String title = scanner.nextLine();
        
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();
        
        Task task = taskService.createTask(title, description);
        System.out.println("Task created with ID: " + task.getId());
    }
    
    private void completeTask() {
        System.out.print("Enter task ID to mark as completed: ");
        String id = scanner.nextLine();
        
        Optional<Task> result = taskService.completeTask(id);
        if (result.isPresent()) {
            System.out.println("Task marked as completed.");
        } else {
            System.out.println("Task not found.");
        }
    }
    
    private void deleteTask() {
        System.out.print("Enter task ID to delete: ");
        String id = scanner.nextLine();
        
        taskService.deleteTask(id);
        System.out.println("Task deleted (if it existed).");
    }
    
    private int readIntInput() {
        try {
            return Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            return -1;
        }
    }
}
EOF

  # Create test file
  cat > "$clean_dir/src/test/java/org/rinna/samples/clean/domain/usecase/TaskServiceTest.java" << 'EOF'
package org.rinna.samples.clean.domain.usecase;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.rinna.samples.clean.adapter.persistence.InMemoryTaskRepository;
import org.rinna.samples.clean.domain.entity.Task;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

class TaskServiceTest {
    private TaskService taskService;
    private TaskRepository taskRepository;

    @BeforeEach
    void setUp() {
        taskRepository = new InMemoryTaskRepository();
        taskService = new TaskService(taskRepository);
    }

    @Test
    void createTask() {
        Task task = taskService.createTask("Test Task", "Description");
        
        assertNotNull(task.getId());
        assertEquals("Test Task", task.getTitle());
        assertEquals("Description", task.getDescription());
        assertFalse(task.isCompleted());
    }

    @Test
    void getTaskById() {
        Task task = taskService.createTask("Test Task", "Description");
        
        Optional<Task> found = taskService.getTaskById(task.getId());
        
        assertTrue(found.isPresent());
        assertEquals(task.getId(), found.get().getId());
    }

    @Test
    void getAllTasks() {
        taskService.createTask("Task 1", "Description 1");
        taskService.createTask("Task 2", "Description 2");
        
        List<Task> tasks = taskService.getAllTasks();
        
        assertEquals(2, tasks.size());
    }

    @Test
    void completeTask() {
        Task task = taskService.createTask("Test Task", "Description");
        
        Optional<Task> completed = taskService.completeTask(task.getId());
        
        assertTrue(completed.isPresent());
        assertTrue(completed.get().isCompleted());
    }

    @Test
    void deleteTask() {
        Task task = taskService.createTask("Test Task", "Description");
        
        taskService.deleteTask(task.getId());
        
        assertTrue(taskService.getTaskById(task.getId()).isEmpty());
    }
}
EOF

  print_success "Created Clean Architecture demo at $clean_dir"
  
  # Try to build the sample projects
  if command_exists mvn; then
    print_step "Building sample projects..."
    
    cd "$hello_dir"
    if mvn clean package -DskipTests; then
      print_success "Successfully built hello-rinna sample"
    else
      print_warning "Failed to build hello-rinna sample"
    fi
    
    cd "$clean_dir"
    if mvn clean package -DskipTests; then
      print_success "Successfully built clean-arch-demo sample"
    else
      print_warning "Failed to build clean-arch-demo sample"
    fi
  else
    print_warning "Maven not available, skipping sample project build"
  fi
  
  print_success "Java sample projects setup completed"
  print_step "To run the samples:"
  print_step "  java -jar $hello_dir/target/hello-rinna-1.0-SNAPSHOT.jar"
  print_step "  java -jar $clean_dir/target/clean-arch-demo-1.0-SNAPSHOT.jar"
  
  return 0
}

# Setup Java environment
setup_java() {
  print_header "Setting up Java environment..."
  
  # Check if Java is already installed with the correct version
  if check_java_version "$REQUIRED_JAVA_VERSION"; then
    print_success "Java $REQUIRED_JAVA_VERSION is already installed"
    return 0
  fi
  
  log "info" "Java $REQUIRED_JAVA_VERSION not found or version mismatch"
  
  # Ask for confirmation if interactive
  if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Java ${REQUIRED_JAVA_VERSION}?"; then
    print_warning "Skipping Java installation"
    return 1
  fi
  
  # Install Java based on the package manager
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      # Ubuntu/Debian approach
      if ! command_exists add-apt-repository; then
        install_packages software-properties-common
      fi
      
      add_repo "ppa:openjdk-r/ppa" "OpenJDK PPA"
      install_packages "openjdk-${REQUIRED_JAVA_VERSION}-jdk"
      ;;
    dnf)
      # Fedora approach
      install_packages "java-${REQUIRED_JAVA_VERSION}-openjdk-devel"
      ;;
    yum)
      # RHEL/CentOS approach
      install_packages "java-${REQUIRED_JAVA_VERSION}-openjdk-devel"
      ;;
    brew)
      # macOS approach
      install_packages "openjdk@${REQUIRED_JAVA_VERSION}"
      # Create symlink in /usr/local/opt
      log "info" "Creating symlink for Java..."
      sudo ln -sfn "$(brew --prefix)/opt/openjdk@${REQUIRED_JAVA_VERSION}/libexec/openjdk.jdk" /Library/Java/JavaVirtualMachines/openjdk-${REQUIRED_JAVA_VERSION}.jdk
      ;;
    *)
      print_error "Automatic Java installation not supported for $PACKAGE_MANAGER"
      print_step "Please install Java $REQUIRED_JAVA_VERSION manually"
      return 1
      ;;
  esac
  
  # Create/update the activate-java.sh script
  cat > "$RINNA_DIR/activate-java.sh" << EOF
#!/usr/bin/env bash
# Java environment setup for Rinna
# Generated by rin-setup-unified on $(date)

# Java Home setup
if [[ -d "/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk-amd64" ]]; then
  export JAVA_HOME="/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk-amd64"
elif [[ -d "/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk" ]]; then
  export JAVA_HOME="/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk"
elif [[ -d "/Library/Java/JavaVirtualMachines/openjdk-${REQUIRED_JAVA_VERSION}.jdk/Contents/Home" ]]; then
  export JAVA_HOME="/Library/Java/JavaVirtualMachines/openjdk-${REQUIRED_JAVA_VERSION}.jdk/Contents/Home"
elif [[ -d "$HOME/.jdks/openjdk-${REQUIRED_JAVA_VERSION}" ]]; then
  export JAVA_HOME="$HOME/.jdks/openjdk-${REQUIRED_JAVA_VERSION}"
elif [[ -d "\$PROGRAMFILES/Java/jdk-${REQUIRED_JAVA_VERSION}" ]]; then
  export JAVA_HOME="\$PROGRAMFILES/Java/jdk-${REQUIRED_JAVA_VERSION}"
elif [[ -d "\$PROGRAMFILES/Eclipse Adoptium/jdk-${REQUIRED_JAVA_VERSION}" ]]; then
  export JAVA_HOME="\$PROGRAMFILES/Eclipse Adoptium/jdk-${REQUIRED_JAVA_VERSION}"
fi

if [[ -n "\$JAVA_HOME" ]]; then
  export PATH="\$JAVA_HOME/bin:\$PATH"
  echo "Using Java \$JAVA_HOME"
  java -version
else
  echo "WARNING: Could not locate Java ${REQUIRED_JAVA_VERSION}"
  echo "Please set JAVA_HOME manually if needed"
fi
EOF
  
  chmod +x "$RINNA_DIR/activate-java.sh"
  print_success "Created Java activation script: activate-java.sh"
  
  # Source the script to set up the environment
  source "$RINNA_DIR/activate-java.sh"
  
  # Verify installation
  if check_java_version "$REQUIRED_JAVA_VERSION"; then
    print_success "Java $REQUIRED_JAVA_VERSION installation successful"
    return 0
  else
    print_error "Java installation failed or version requirements not met"
    return 1
  fi
}

# Setup Go environment
setup_go() {
  print_header "Setting up Go environment..."
  
  # Check if Go is already installed with the correct version
  if check_go_version "$REQUIRED_GO_VERSION"; then
    print_success "Go $REQUIRED_GO_VERSION is already installed"
    return 0
  fi
  
  log "info" "Go $REQUIRED_GO_VERSION not found or version mismatch"
  
  # Ask for confirmation if interactive
  if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Go ${REQUIRED_GO_VERSION}?"; then
    print_warning "Skipping Go installation"
    return 1
  fi
  
  # Install Go based on the package manager
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      # Check if golang-go is new enough in the default repos
      if apt-cache policy golang-go | grep -q "$REQUIRED_GO_VERSION"; then
        install_packages golang-go
      else
        # Add the longsleep/golang-backports PPA for newer Go versions
        if ! command_exists add-apt-repository; then
          install_packages software-properties-common
        fi
        
        add_repo "ppa:longsleep/golang-backports" "Go Backports PPA"
        install_packages "golang-${REQUIRED_GO_VERSION}"
      fi
      ;;
    dnf|yum)
      install_packages "golang"
      # Check if the installed version meets the requirement
      if ! check_go_version "$REQUIRED_GO_VERSION"; then
        # Alternative: download and install from golang.org
        log "info" "Installing Go from golang.org..."
        local arch=$(uname -m)
        [[ "$arch" == "x86_64" ]] && arch="amd64"
        
        local go_tar="go${REQUIRED_GO_VERSION}.linux-${arch}.tar.gz"
        local download_url="https://golang.org/dl/${go_tar}"
        
        mkdir -p "$HOME/go_install"
        curl -L "$download_url" -o "$HOME/go_install/${go_tar}"
        # Safely remove Go installation - don't use rm -rf directly on /usr paths
        if [ -d "/usr/local/go" ]; then
          sudo rm -rf "/usr/local/go"
        fi
        sudo tar -C /usr/local -xzf "$HOME/go_install/${go_tar}"
        rm -rf "$HOME/go_install"
        
        # Add to PATH in profile
        if [[ ! -f "$HOME/.profile" || ! $(grep -q "GOPATH" "$HOME/.profile") ]]; then
          echo 'export PATH=$PATH:/usr/local/go/bin' >> "$HOME/.profile"
          echo 'export GOPATH=$HOME/go' >> "$HOME/.profile"
          echo 'export PATH=$PATH:$GOPATH/bin' >> "$HOME/.profile"
        fi
        
        export PATH=$PATH:/usr/local/go/bin
        export GOPATH=$HOME/go
        export PATH=$PATH:$GOPATH/bin
      fi
      ;;
    brew)
      install_packages go
      ;;
    *)
      print_error "Automatic Go installation not supported for $PACKAGE_MANAGER"
      print_step "Please install Go $REQUIRED_GO_VERSION manually"
      return 1
      ;;
  esac
  
  # Create/update the activate-go.sh script
  cat > "$RINNA_DIR/activate-go.sh" << EOF
#!/usr/bin/env bash
# Go environment setup for Rinna
# Generated by rin-setup-unified on $(date)

# Go environment setup
if [[ -d "/usr/local/go" ]]; then
  export GOROOT="/usr/local/go"
  export PATH="\$GOROOT/bin:\$PATH"
elif command -v go &>/dev/null; then
  export GOROOT="\$(go env GOROOT 2>/dev/null)"
fi

# Set GOPATH if not already set
if [[ -z "\$GOPATH" ]]; then
  export GOPATH="\$HOME/go"
  mkdir -p "\$GOPATH"
fi

# Add GOPATH/bin to PATH
export PATH="\$PATH:\$GOPATH/bin"

# Set project-specific Go paths
export RINNA_GO_DIR="\$RINNA_DIR/api"
export GO111MODULE=on

echo "Go environment configured:"
echo "  GOROOT: \$GOROOT"
echo "  GOPATH: \$GOPATH"
EOF
  
  chmod +x "$RINNA_DIR/activate-go.sh"
  print_success "Created Go activation script: activate-go.sh"
  
  # Source the script to set up the environment
  source "$RINNA_DIR/activate-go.sh"
  
  # Verify installation
  if check_go_version "$REQUIRED_GO_VERSION"; then
    print_success "Go $REQUIRED_GO_VERSION installation successful"
    return 0
  else
    print_error "Go installation failed or version requirements not met"
    return 1
  fi
}

# Setup Python environment (base system Python)
setup_python() {
  print_header "Setting up Python environment..."
  
  # Find the Python executable
  local python_cmd=""
  if command_exists python3; then
    python_cmd="python3"
  elif command_exists python; then
    if python --version 2>&1 | grep -q "Python 3"; then
      python_cmd="python"
    fi
  fi
  
  if [[ -z "$python_cmd" ]]; then
    print_error "Python 3 is not installed"
    
    # Ask for confirmation if interactive
    if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Python ${REQUIRED_PYTHON_VERSION}?"; then
      print_warning "Skipping Python installation"
      return 1
    fi
    
    # Install Python based on package manager
    case "$PACKAGE_MANAGER" in
      apt|apt-get)
        install_packages python3 python3-pip python3-venv python3-dev
        ;;
      dnf|yum)
        install_packages python3 python3-pip python3-devel
        ;;
      brew)
        install_packages python
        ;;
      *)
        print_error "Automatic Python installation not supported for $PACKAGE_MANAGER"
        print_step "Please install Python $REQUIRED_PYTHON_VERSION manually"
        return 1
        ;;
    esac
    
    # Find Python again after installation
    if command_exists python3; then
      python_cmd="python3"
    elif command_exists python && python --version 2>&1 | grep -q "Python 3"; then
      python_cmd="python"
    else
      print_error "Python installation failed"
      return 1
    fi
  fi
  
  # Check Python version
  local py_version
  py_version=$($python_cmd --version 2>&1 | sed 's/Python //')
  local py_major=$(echo "$py_version" | cut -d. -f1)
  local py_minor=$(echo "$py_version" | cut -d. -f2)
  
  local req_major=$(echo "$REQUIRED_PYTHON_VERSION" | cut -d. -f1)
  local req_minor=$(echo "$REQUIRED_PYTHON_VERSION" | cut -d. -f2)
  
  if [[ "$py_major" -lt "$req_major" || ("$py_major" -eq "$req_major" && "$py_minor" -lt "$req_minor") ]]; then
    print_error "Python $REQUIRED_PYTHON_VERSION or higher is required (found $py_version)"
    
    # Ask for confirmation if interactive
    if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Python ${REQUIRED_PYTHON_VERSION}?"; then
      print_warning "Skipping Python upgrade"
      return 1
    fi
    
    # Attempt to upgrade Python (this is platform-dependent)
    case "$PACKAGE_MANAGER" in
      apt|apt-get)
        # Try using deadsnakes PPA for newer Python versions
        if ! command_exists add-apt-repository; then
          install_packages software-properties-common
        fi
        
        add_repo "ppa:deadsnakes/ppa" "Deadsnakes PPA"
        install_packages "python${REQUIRED_PYTHON_VERSION}" "python${REQUIRED_PYTHON_VERSION}-venv" "python${REQUIRED_PYTHON_VERSION}-dev"
        ;;
      dnf)
        # Fedora may have newer Pythons available
        install_packages "python${REQUIRED_PYTHON_VERSION}" "python${REQUIRED_PYTHON_VERSION}-devel"
        ;;
      brew)
        install_packages "python@${REQUIRED_PYTHON_VERSION}"
        ;;
      *)
        print_error "Python version upgrade not supported automatically"
        print_step "Please upgrade Python to $REQUIRED_PYTHON_VERSION or higher manually"
        return 1
        ;;
    esac
    
    # Check if Python is installed with correct version
    if command_exists "python${req_major}.${req_minor}"; then
      python_cmd="python${req_major}.${req_minor}"
    elif command_exists python3 && python3 --version 2>&1 | grep -q "Python ${req_major}\.${req_minor}"; then
      python_cmd="python3"
    else
      print_error "Python upgrade failed"
      return 1
    fi
  fi
  
  # Check for venv module
  if ! $python_cmd -c "import venv" &> /dev/null; then
    print_error "Python venv module is not available"
    
    # Ask for confirmation if interactive
    if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Python venv module?"; then
      print_warning "Skipping venv module installation"
      return 1
    fi
    
    case "$PACKAGE_MANAGER" in
      apt|apt-get)
        log "info" "Installing python3-venv..."
        install_packages python3-venv
        ;;
      dnf|yum)
        log "info" "Installing python3-devel..."
        install_packages python3-devel
        ;;
      brew)
        print_warning "On macOS, venv should be included with Python"
        print_step "If issues persist, try reinstalling Python with: brew reinstall python"
        ;;
      *)
        print_error "Automatic venv installation not supported for $PACKAGE_MANAGER"
        print_step "Please install Python venv module manually"
        return 1
        ;;
    esac
  fi
  
  # Create/update the activate-python.sh script (for system Python, not venv)
  cat > "$RINNA_DIR/activate-system-python.sh" << EOF
#!/usr/bin/env bash
# System Python environment setup for Rinna
# Generated by rin-setup-unified on $(date)

# Set Python environment variables
export PYTHONPATH="\$RINNA_DIR:\$RINNA_DIR/python"

# Use the correct Python version
if command -v python${req_major}.${req_minor} &>/dev/null; then
  alias python=python${req_major}.${req_minor}
  alias pip=pip${req_major}.${req_minor}
else
  # Fall back to python3
  alias python=python3
  alias pip=pip3
fi

# Add local bin directory to PATH if it exists
if [[ -d "\$HOME/.local/bin" ]]; then
  export PATH="\$HOME/.local/bin:\$PATH"
fi

echo "System Python environment configured"
python --version
EOF
  
  chmod +x "$RINNA_DIR/activate-system-python.sh"
  print_success "Created Python activation script: activate-system-python.sh"
  
  print_success "Python $py_version setup complete"
  return 0
}

# Setup Maven build system
setup_maven() {
  print_header "Setting up Maven build system..."
  
  # Check if Maven is already installed 
  if command_exists mvn; then
    local mvn_version
    mvn_version=$(mvn --version | grep -oE "Apache Maven [0-9]+\.[0-9]+\.[0-9]+" | cut -d' ' -f3)
    print_success "Maven $mvn_version is already installed"
    return 0
  fi
  
  log "info" "Maven not found"
  
  # Ask for confirmation if interactive
  if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Maven?"; then
    print_warning "Skipping Maven installation"
    return 1
  fi
  
  # Install Maven based on the package manager
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      install_packages maven
      ;;
    dnf|yum)
      install_packages maven
      ;;
    brew)
      install_packages maven
      ;;
    *)
      print_error "Automatic Maven installation not supported for $PACKAGE_MANAGER"
      print_step "Please install Maven manually"
      return 1
      ;;
  esac
  
  # Verify installation
  if command_exists mvn; then
    local mvn_version
    mvn_version=$(mvn --version | grep -oE "Apache Maven [0-9]+\.[0-9]+\.[0-9]+" | cut -d' ' -f3)
    print_success "Maven $mvn_version installation successful"
    return 0
  else
    print_error "Maven installation failed"
    return 1
  fi
}

# Setup API service
setup_api() {
  print_header "Setting up API service..."
  
  # Check if Go is available
  if ! command_exists go; then
    print_error "Go is required for API setup but not found"
    print_step "Please run 'bin/rin-setup-unified go' first"
    return 1
  fi
  
  # Check API directory structure
  local api_dir="$RINNA_DIR/api"
  if [[ ! -d "$api_dir" ]]; then
    print_warning "API directory not found at $api_dir"
    print_step "Creating API directory structure..."
    mkdir -p "$api_dir/cmd/rinnasrv"
    mkdir -p "$api_dir/internal/handlers"
    mkdir -p "$api_dir/internal/middleware"
    mkdir -p "$api_dir/internal/models"
    mkdir -p "$api_dir/pkg/config"
    mkdir -p "$api_dir/pkg/health"
    mkdir -p "$api_dir/configs"
    mkdir -p "$api_dir/test/integration"
    print_success "Created API directory structure"
  else
    print_success "API directory structure already exists"
  fi
  
  # Check for go.mod
  if [[ ! -f "$api_dir/go.mod" ]]; then
    print_step "Initializing Go module..."
    cd "$api_dir"
    go mod init github.com/rinna/api
    print_success "Initialized Go module"
  else
    print_success "Go module already initialized"
  fi
  
  # Check for config.yaml
  local config_file="$api_dir/configs/config.yaml"
  if [[ ! -f "$config_file" ]]; then
    print_step "Creating API configuration file..."
    
    mkdir -p "$(dirname "$config_file")"
    cat > "$config_file" << EOF
# Rinna API Configuration
# Generated by rin-setup-unified on $(date)

# Server settings
server:
  port: 8080
  host: "localhost"
  read_timeout_seconds: 30
  write_timeout_seconds: 30
  shutdown_timeout_seconds: 10

# Logging configuration
logging:
  level: "info"  # debug, info, warn, error, fatal
  format: "json"  # text or json
  output: "stdout"  # stdout, stderr, or file path

# Health checks
health:
  enabled: true
  endpoint: "/health"
  status_path: "/status"

# Middleware settings
middleware:
  cors:
    enabled: true
    allowed_origins: ["*"]
    allowed_methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
    allowed_headers: ["Content-Type", "Authorization"]
  auth:
    enabled: false
    jwt_secret: ""
    token_expiration_hours: 24

# Rate limiting
rate_limit:
  enabled: true
  requests_per_minute: 60
  burst: 10

# Metrics
metrics:
  enabled: true
  endpoint: "/metrics"

# Database settings
database:
  type: "memory"  # memory, sqlite, postgres, mysql
  connection_string: ""
  max_open_conns: 10
  max_idle_conns: 5
  conn_max_lifetime_seconds: 3600
EOF
    
    print_success "Created API configuration file at $config_file"
  else
    print_success "API configuration file already exists"
  fi
  
  # Check for main.go in rinnasrv
  local main_file="$api_dir/cmd/rinnasrv/main.go"
  if [[ ! -f "$main_file" ]]; then
    print_step "Creating minimal API server..."
    
    mkdir -p "$(dirname "$main_file")"
    cat > "$main_file" << 'EOF'
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	port := getEnv("PORT", "8080")
	addr := fmt.Sprintf(":%s", port)

	// Create a basic router
	mux := http.NewServeMux()
	
	// Add health check endpoint
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"status":"UP","version":"development"}`))
	})
	
	// Add root endpoint
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/" {
			http.NotFound(w, r)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"message":"Rinna API Server","status":"running"}`))
	})

	// Create server with reasonable timeouts
	server := &http.Server{
		Addr:         addr,
		Handler:      mux,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Start server in a goroutine
	go func() {
		log.Printf("Starting server on %s", addr)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Server error: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shut down the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Shutting down server...")

	// Create a deadline to wait for current operations to complete
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	
	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server gracefully stopped")
}

// getEnv retrieves an environment variable or returns a default value
func getEnv(key, defaultValue string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return defaultValue
}
EOF
    
    print_success "Created minimal API server at $main_file"
  else
    print_success "API server already exists"
  fi
  
  # Create health package
  local health_file="$api_dir/pkg/health/health.go"
  if [[ ! -f "$health_file" ]]; then
    print_step "Creating health check package..."
    
    mkdir -p "$(dirname "$health_file")"
    cat > "$health_file" << 'EOF'
package health

import (
	"encoding/json"
	"fmt"
	"net/http"
	"runtime"
	"time"
)

// Status represents the health status of the application
type Status struct {
	Status    string            `json:"status"`
	Version   string            `json:"version"`
	Timestamp string            `json:"timestamp"`
	Uptime    string            `json:"uptime"`
	GoVersion string            `json:"goVersion"`
	Memory    uint64            `json:"memoryUsageMB"`
	Checks    map[string]string `json:"checks,omitempty"`
}

// Handler returns an HTTP handler for health checks
func Handler(version string, startTime time.Time) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		
		// Basic health check
		status := Status{
			Status:    "UP",
			Version:   version,
			Timestamp: time.Now().Format(time.RFC3339),
			Uptime:    fmt.Sprintf("%s", time.Since(startTime).Round(time.Second)),
			GoVersion: runtime.Version(),
			Memory:    getMemoryUsage(),
			Checks:    make(map[string]string),
		}
		
		// Run additional checks here
		
		// Serialize and send response
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(status)
	}
}

// getMemoryUsage returns memory usage in MB
func getMemoryUsage() uint64 {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	return m.Alloc / 1024 / 1024
}
EOF
    
    print_success "Created health check package at $health_file"
  else
    print_success "Health check package already exists"
  fi
  
  # Check if go.sum exists, if not run go mod tidy
  if [[ ! -f "$api_dir/go.sum" ]]; then
    print_step "Resolving Go dependencies..."
    cd "$api_dir"
    go mod tidy
    print_success "Dependencies resolved"
  fi
  
  # Attempt to build the API server
  print_step "Building API server..."
  cd "$api_dir"
  if go build -o bin/rinnasrv ./cmd/rinnasrv; then
    print_success "API server built successfully"
  else
    print_warning "Failed to build API server. Check Go configuration."
    return 1
  fi
  
  # Create API activation script
  local activate_script="$RINNA_DIR/activate-api.sh"
  cat > "$activate_script" << EOF
#!/usr/bin/env bash
# API environment setup for Rinna
# Generated by rin-setup-unified on $(date)

# Set API environment variables
export RINNA_API_DIR="$api_dir"
export PATH="\$RINNA_API_DIR/bin:\$PATH"
export GO111MODULE=on

# Print status
echo "Rinna API environment activated"
echo "API directory: \$RINNA_API_DIR"
EOF

  chmod +x "$activate_script"
  print_success "Created API activation script at $activate_script"
  
  print_step "API service setup complete"
  print_success "You can start the API with: $api_dir/bin/rinnasrv"
  
  return 0
}

# Setup configuration files
setup_config() {
  print_header "Setting up configuration files..."
  
  # Check if config directory exists
  if [[ ! -d "$RINNA_DIR/config" ]]; then
    mkdir -p "$RINNA_DIR/config"
    print_success "Created config directory"
  fi
  
  # Setup main configuration file
  local main_config="$RINNA_DIR/config/rinna.yaml"
  if [[ ! -f "$main_config" ]]; then
    debug_echo "Creating main configuration file"
    
    cat > "$main_config" << EOF
# Rinna Configuration File
# Generated by rin-setup-unified on $(date)

# Environment configuration
environment:
  # Production, Development, Testing, or CI
  mode: Development

# Java settings
java:
  version: "$REQUIRED_JAVA_VERSION"
  options: "-Xmx1024m"

# Go settings
go:
  version: "$REQUIRED_GO_VERSION"
  module: "github.com/rinna/api"

# Python settings
python:
  version: "$REQUIRED_PYTHON_VERSION"
  virtual_env: ".venv"
  requirements: "requirements.txt"

# Database settings
database:
  type: "memory"  # Options: memory, sqlite, postgres, mysql
  connection: ""

# Logging configuration
logging:
  level: "info"  # Options: debug, info, warn, error
  file: "logs/rinna.log"
  max_size_mb: 10
  max_backups: 5
  compress: true

# Service configuration
services:
  api:
    port: 8080
    address: "localhost"
    timeout_seconds: 30
    max_requests: 1000
EOF

    print_success "Created main configuration file at $main_config"
  else
    print_success "Main configuration file already exists"
  fi
  
  # Create config symlinks if needed
  if [[ ! -f "$RINNA_DIR/.rinna-config" ]]; then
    ln -sf "$main_config" "$RINNA_DIR/.rinna-config"
    print_success "Created configuration symlink"
  fi
  
  # Create sample user config if not exists
  if [[ ! -d "$HOME/.rinna" ]]; then
    mkdir -p "$HOME/.rinna"
  fi
  
  local user_config="$HOME/.rinna/config.yaml"
  if [[ ! -f "$user_config" ]]; then
    cat > "$user_config" << EOF
# User specific configuration for Rinna
# Generated by rin-setup-unified on $(date)

# User preferences
preferences:
  editor: "${EDITOR:-auto}"
  theme: "default"
  color_mode: "auto"  # Options: auto, light, dark

# Personal workspace settings
workspace:
  path: "~/rinna-workspace"
  default_project: "default"
EOF
    
    print_success "Created user configuration at $user_config"
  else
    print_success "User configuration already exists"
  fi
  
  return 0
}

# Create Python virtual environment
setup_python_venv() {
  print_header "Setting up Python virtual environment..."
  
  # Constants
  local venv_dir="$RINNA_DIR/.venv"
  local requirements_file="$RINNA_DIR/requirements.txt"
  
  # Check if venv exists and force flag is set
  if [[ -d "$venv_dir" ]]; then
    if [[ "$FORCE" == "true" ]]; then
      log "info" "Removing existing virtual environment"
      rm -rf "$venv_dir"
    else
      print_success "Virtual environment already exists at $venv_dir"
      
      # Create activation script regardless
      create_python_activation_script "$venv_dir"
      return 0
    fi
  fi
  
  # Find Python executable
  local python_cmd
  if command_exists python3; then
    python_cmd="python3"
  elif command_exists python && python --version 2>&1 | grep -q "Python 3"; then
    python_cmd="python"
  else
    print_error "Python 3 not found"
    return 1
  fi
  
  # Create virtual environment
  log "info" "Creating virtual environment at $venv_dir"
  if [[ "$VERBOSE" == "true" ]]; then
    $python_cmd -m venv "$venv_dir"
  else
    $python_cmd -m venv "$venv_dir" &> /dev/null
  fi
  
  if [[ ! -f "$venv_dir/bin/activate" ]]; then
    print_error "Failed to create virtual environment"
    return 1
  fi
  
  print_success "Virtual environment created successfully"
  
  # Use pip from venv
  local pip="$venv_dir/bin/pip"
  
  # Update pip to latest version
  log "info" "Updating pip to latest version"
  if [[ "$VERBOSE" == "true" ]]; then
    "$pip" install --upgrade pip
  else
    "$pip" install --upgrade pip &> /dev/null
  fi
  
  # Check if requirements file exists
  if [[ ! -f "$requirements_file" ]]; then
    log "warning" "Requirements file not found at $requirements_file"
    
    # Create a basic requirements file
    cat > "$requirements_file" << EOF
# Rinna Python dependencies
# Generated by rin-setup-unified on $(date)

# Core dependencies
pyyaml>=6.0
requests>=2.28.0
pytest>=7.0.0
pytest-cov>=4.0.0

# Optional dependencies
diagrams>=0.23.0  # (optional) For generating architecture diagrams
black>=23.0.0     # (optional) Code formatter
ruff>=0.0.260     # (optional) Linter
mypy>=1.0.0       # (optional) Type checker
bandit>=1.7.5     # (optional) Security checker
EOF
    
    log "info" "Created basic requirements.txt file"
  fi
  
  # Install dependencies from requirements.txt
  log "info" "Installing Python dependencies"
  
  # Install wheel first to help with binary packages
  if [[ "$VERBOSE" == "true" ]]; then
    "$pip" install wheel
  else
    "$pip" install wheel &> /dev/null
  fi

  # Parse requirements.txt to separate regular and optional dependencies
  local temp_req=$(mktemp)
  
  # Extract non-optional requirements
  grep -v "(optional)" "$requirements_file" | grep -v "^#" | grep -v "^$" > "$temp_req"
  
  local active_req
  if [[ "$PYTHON_INSTALL_OPTIONAL" == "true" ]]; then
    # If installing optional deps, use the original file
    active_req="$requirements_file"
    log "info" "Will install ALL dependencies including optional ones"
  else
    # Otherwise use the filtered file
    active_req="$temp_req"
    log "info" "Will install only required dependencies (use --all for optional deps)"
  fi
  
  # Install dependencies
  if [[ "$VERBOSE" == "true" ]]; then
    "$pip" install -r "$active_req" --upgrade
  else
    # Show a progress message since this might take a while
    echo -n "Installing packages..."
    "$pip" install -r "$active_req" --upgrade &> /dev/null || {
      echo " failed!"
      print_error "Failed to install dependencies. Run with --verbose to see the errors."
      rm -f "$temp_req"
      return 1
    }
    echo " done!"
  fi
  
  # Cleanup temporary file
  rm -f "$temp_req"
  
  # Check for system dependencies that might be needed
  if [[ "$PYTHON_INSTALL_OPTIONAL" == "true" && "$SKIP_SYSTEM" != "true" ]]; then
    if grep -q "diagrams" "$requirements_file"; then
      if ! command_exists dot; then
        log "info" "Installing graphviz for diagrams package"
        install_packages graphviz
      fi
    fi
  fi
  
  # Add version file to virtual environment
  update_venv_version "$venv_dir"
  
  # Create activation script
  create_python_activation_script "$venv_dir"
  
  # Create .env file for VS Code and other tools
  create_env_file "$venv_dir"
  
  print_success "Python virtual environment setup complete"
  return 0
}

# Update virtual environment version information
update_venv_version() {
  local venv_dir="$1"
  
  # Get project version from version.properties
  local version
  version=$(get_version)
  
  # Create version file in virtual environment
  echo "$version" > "$venv_dir/version"
  
  # Create a Python module with version info
  local py_sitepackages
  py_sitepackages=$($venv_dir/bin/python -c "import site; print(site.getsitepackages()[0])")
  local venv_info_dir="$py_sitepackages/rinna_venv_info"
  mkdir -p "$venv_info_dir"
  
  # Create __init__.py
  cat > "$venv_info_dir/__init__.py" << EOF
"""Rinna virtual environment information."""

VERSION = "$version"
CREATION_DATE = "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
PYTHON_VERSION = "$($venv_dir/bin/python --version 2>&1 | cut -d' ' -f2)"

def get_version():
    """Return the Rinna project version."""
    return VERSION

def get_info():
    """Return dictionary with virtual environment information."""
    return {
        "version": VERSION,
        "creation_date": CREATION_DATE,
        "python_version": PYTHON_VERSION,
    }

def print_info():
    """Print virtual environment information."""
    print(f"Rinna Virtual Environment")
    print(f"Version: {VERSION}")
    print(f"Created: {CREATION_DATE}")
    print(f"Python:  {PYTHON_VERSION}")
EOF

  # Create __main__.py for direct module execution
  cat > "$venv_info_dir/__main__.py" << EOF
"""Main entry point for rinna_venv_info package."""

from rinna_venv_info import print_info

# Print environment info when module is executed directly
print_info()
EOF
  
  log "info" "Created Python version module in virtual environment"
}

# Create Python virtual environment activation script
create_python_activation_script() {
  local venv_dir="$1"
  local activate_script="$RINNA_DIR/activate-python.sh"
  
  cat > "$activate_script" << EOF
#!/usr/bin/env bash
#
# activate-python.sh - Activate Python virtual environment for Rinna
# Generated by rin-setup-unified on $(date)
#

# Activate the virtual environment
if [[ -f "$venv_dir/bin/activate" ]]; then
    source "$venv_dir/bin/activate"
    
    # Set project environment variables
    export RINNA_ROOT="$RINNA_DIR"
    export RINNA_VERSION=\$(cat "$venv_dir/version" 2>/dev/null || echo "unknown")
    export PYTHONPATH="\$RINNA_ROOT:\$RINNA_ROOT/python"
    
    # Show version info
    if python -c "import rinna_venv_info" &>/dev/null; then
        python -m rinna_venv_info
    else
        echo "Rinna Python environment activated (version \$RINNA_VERSION)"
    fi
    
    echo "Run 'deactivate' to exit the virtual environment"
else
    echo "Error: Virtual environment not found at $venv_dir"
    echo "Run 'bin/rin-setup-unified python venv' to create it"
    return 1
fi
EOF
  
  chmod +x "$activate_script"
  print_success "Created activation script at $activate_script"
}

# Create .env file for VS Code and other tools
create_env_file() {
  local venv_dir="$1"
  local env_file="$RINNA_DIR/.env"
  
  cat > "$env_file" << EOF
# Python environment variables for Rinna
# Generated by rin-setup-unified on $(date)
PYTHONPATH=${RINNA_DIR}:${RINNA_DIR}/python
VIRTUAL_ENV=${venv_dir}
EOF
  
  # For VS Code, also create settings if they don't exist
  local vscode_dir="$RINNA_DIR/.vscode"
  local settings_file="$vscode_dir/settings.json"
  
  if [[ ! -d "$vscode_dir" ]]; then
    mkdir -p "$vscode_dir"
  fi
  
  if [[ ! -f "$settings_file" ]]; then
    cat > "$settings_file" << EOF
{
    "python.defaultInterpreterPath": "${venv_dir}/bin/python",
    "python.analysis.extraPaths": [
        "${RINNA_DIR}",
        "${RINNA_DIR}/python"
    ],
    "python.testing.pytestEnabled": true,
    "python.linting.enabled": true,
    "java.configuration.updateBuildConfiguration": "automatic",
    "go.toolsEnvVars": {
        "GO111MODULE": "on"
    }
}
EOF
    log "info" "Created VS Code settings at $settings_file"
  fi
  
  log "info" "Created .env file at $env_file"
}

# Setup UI configuration (minimal/text UI)
setup_ui() {
  print_header "Setting up UI configuration..."
  
  # Create .rinna directory in home for user-specific settings
  mkdir -p "$HOME/.rinna"
  
  # Create empty user configuration file if it doesn't exist
  local user_config="$HOME/.rinna/config.yaml"
  if [[ ! -f "$user_config" ]]; then
    cat > "$user_config" << EOF
# Rinna User Configuration
# Generated by rin-setup-unified on $(date)

# User interface settings
ui:
  theme: default
  colors: true
  unicode: true
  verbose: false

# Default settings
defaults:
  project: default
  workflow: standard
  editor: auto

# Paths
paths:
  workspace: ~/rinna-workspace
  data: ~/.rinna/data
  logs: ~/.rinna/logs
  cache: ~/.rinna/cache

# Tools
tools:
  editor: ${EDITOR:-auto}
  browser: auto
  diff: auto
EOF
    
    print_success "Created user configuration at $user_config"
  else
    log "info" "User configuration already exists at $user_config"
  fi
  
  # Ensure bin directory scripts are executable
  log "info" "Ensuring CLI scripts are executable..."
  
  local bin_files=(
    "$RINNA_DIR/bin/rin"
    "$RINNA_DIR/bin/rin-build"
    "$RINNA_DIR/bin/rin-version"
    "$RINNA_DIR/bin/rin-setup"
    "$RINNA_DIR/bin/rin-setup-unified"
    "$RINNA_DIR/bin/rin-doc"
    "$RINNA_DIR/bin/setup-python.sh"
    "$RINNA_DIR/bin/install-rinna.sh"
  )
  
  for file in "${bin_files[@]}"; do
    if [[ -f "$file" ]]; then
      chmod +x "$file"
      log "info" "Made executable: $(basename "$file")"
    fi
  done
  
  # Create symbolic links in user's bin directory if possible
  local user_bin="$HOME/.local/bin"
  if [[ ! -d "$user_bin" ]]; then
    mkdir -p "$user_bin"
  fi
  
  if [[ -d "$user_bin" ]]; then
    if [[ ! -L "$user_bin/rin" || $(readlink -f "$user_bin/rin") != "$RINNA_DIR/bin/rin" ]]; then
      ln -sf "$RINNA_DIR/bin/rin" "$user_bin/rin"
      print_success "Created symlink in $user_bin/rin"
    fi
    
    # Add bin directory to PATH if not already present
    if ! echo "$PATH" | grep -q "$user_bin"; then
      print_warning "Please add $user_bin to your PATH"
      print_step "Add this line to your shell profile (~/.bashrc, ~/.zshrc, etc.):"
      print_step "export PATH=\"$user_bin:\$PATH\""
    fi
  fi
  
  print_success "UI configuration complete"
  return 0
}

# Test the entire environment
test_environment() {
  if [[ "$SKIP_TESTS" == "true" ]]; then
    log "info" "Skipping environment tests (--skip-tests flag provided)"
    return 0
  fi
  
  print_header "Testing Rinna environment..."
  local all_passed=true
  
  # Test Java build if available
  if command_exists java && command_exists mvn; then
    log "info" "Testing Java build..."
    if ! cd "$RINNA_DIR" && mvn compile -DskipTests -P skip-quality -q; then
      print_error "Java build test failed"
      all_passed=false
    else
      print_success "Java build test passed"
    fi
  fi
  
  # Test Go build if available
  if command_exists go; then
    log "info" "Testing Go build..."
    if [[ -d "$RINNA_DIR/api" && -f "$RINNA_DIR/api/go.mod" ]]; then
      if ! cd "$RINNA_DIR/api" && go build ./cmd/healthcheck; then
        print_error "Go build test failed"
        all_passed=false
      else
        print_success "Go build test passed"
      fi
    else
      log "warning" "Skipping Go build test (missing go.mod)"
    fi
  fi
  
  # Test Python if available
  if command_exists python3; then
    log "info" "Testing Python..."
    if ! python3 -c "print('Python is working')" &>/dev/null; then
      print_error "Python test failed"
      all_passed=false
    else
      print_success "Python test passed"
    fi
  fi
  
  # Return to project root
  cd "$RINNA_DIR"
  
  if [[ "$all_passed" == true ]]; then
    print_success "All environment tests passed!"
    return 0
  else
    print_warning "Some environment tests failed"
    return 1
  fi
}

# Run the graphical installer
run_graphical_installer() {
  print_header "Running graphical installer..."
  
  local installer_script="$RINNA_DIR/bin/install-rinna.sh"
  
  if [[ ! -x "$installer_script" ]]; then
    print_error "Graphical installer not found or not executable: $installer_script"
    return 1
  fi
  
  # Run installer with appropriate options
  if [[ "$MODE" == "fast" ]]; then
    "$installer_script" --fast
  else
    "$installer_script"
  fi
  
  return 0
}

# Fast mode setup
run_fast_setup() {
  print_header "Running fast setup..."
  
  # Set up components in sequence
  local results=()
  local component
  
  for component in "${COMPONENTS[@]}"; do
    case "$component" in
      java)
        setup_java
        results+=($?)
        ;;
      go)
        setup_go
        results+=($?)
        ;;
      python)
        setup_python
        results+=($?)
        ;;
      maven)
        setup_maven
        results+=($?)
        ;;
      config)
        setup_config
        results+=($?)
        ;;
      venv)
        setup_python_venv
        results+=($?)
        ;;
      ui)
        setup_ui
        results+=($?)
        ;;
      api)
        setup_api
        results+=($?)
        ;;
      samples)
        setup_java_samples
        results+=($?)
        ;;
      *)
        print_warning "Unknown component: $component"
        ;;
    esac
  done
  
  # Test the environment if requested
  if [[ "$SKIP_TESTS" != "true" ]]; then
    test_environment
    results+=($?)
  fi
  
  # Count failures
  local failures=0
  for result in "${results[@]}"; do
    ((failures += result))
  done
  
  if [[ $failures -eq 0 ]]; then
    print_success "Fast setup completed successfully"
    return 0
  else
    print_warning "Fast setup completed with $failures failures"
    return 1
  fi
}

# Create a master activation script that sources all component-specific scripts
create_master_activation() {
  print_header "Creating master activation script..."
  
  local activate_script="$RINNA_DIR/activate-rinna.sh"
  
  cat > "$activate_script" << EOF
#!/usr/bin/env bash
#
# activate-rinna.sh - Master activation script for Rinna environment
# Generated by rin-setup-unified on $(date)
#

# Save current directory
export RINNA_DIR="$(cd "$RINNA_DIR" && pwd)"
export RINNA_VERSION="$(get_version)"

# Function to load component if available
load_component() {
  local script="\$1"
  local name="\$2"
  
  if [[ -f "\$script" ]]; then
    echo "Loading \$name environment..."
    source "\$script"
    return 0
  fi
  return 1
}

# Clear any existing Rinna environment
# This prevents stacking environments if sourced multiple times
if [[ -n "\$RINNA_ENV_ACTIVE" ]]; then
  echo "Refreshing Rinna environment..."
  # If we had a Python venv activated, deactivate it
  if [[ -n "\$VIRTUAL_ENV" ]]; then
    deactivate 2>/dev/null || true
  fi
fi

# Load component configurations
load_component "\$RINNA_DIR/activate-java.sh" "Java"
load_component "\$RINNA_DIR/activate-go.sh" "Go"

# Python environment - prefer venv but fall back to system
if [[ -f "\$RINNA_DIR/activate-python.sh" ]]; then
  load_component "\$RINNA_DIR/activate-python.sh" "Python virtual environment"
else
  load_component "\$RINNA_DIR/activate-system-python.sh" "System Python"
fi

# Mark environment as active
export RINNA_ENV_ACTIVE="true"

# Add bin directory to path
export PATH="\$RINNA_DIR/bin:\$PATH"

# Display environment information
echo ""
echo "Rinna environment activated (version \$RINNA_VERSION)"
echo "Run 'deactivate-rinna' to exit this environment"

# Define deactivation function
deactivate-rinna() {
  if [[ -n "\$VIRTUAL_ENV" ]]; then
    deactivate
  fi
  
  # Restore PATH (remove our bin directory)
  export PATH="\${PATH//\$RINNA_DIR\/bin:/}"
  
  # Unset variables
  unset RINNA_ENV_ACTIVE
  unset RINNA_DIR
  unset deactivate-rinna
  
  echo "Rinna environment deactivated"
}
EOF
  
  chmod +x "$activate_script"
  print_success "Created master activation script at $activate_script"
}

# Display final message
display_final_message() {
  print_header "Setup Complete!"
  echo ""
  echo "Rinna has been set up successfully."
  echo ""
  echo "To activate the full Rinna environment, run:"
  echo "  source $RINNA_DIR/activate-rinna.sh"
  echo ""
  echo "For component-specific environments:"
  echo "  Java:   source $RINNA_DIR/activate-java.sh"
  echo "  Go:     source $RINNA_DIR/activate-go.sh"
  echo "  Python: source $RINNA_DIR/activate-python.sh"
  echo ""
  echo "To start using Rinna, run:"
  echo "  bin/rin --help"
  echo ""
}

# Main function
main() {
  debug_echo "Starting main function with arguments: $*"
  
  # Parse command line arguments
  parse_args "$@"
  
  # Add trap for error handling
  trap 'echo -e "\033[0;31m✗ Error occurred at line $LINENO\033[0m" >&2' ERR
  
  # Show logo
  print_logo
  
  # Choose setup mode
  debug_echo "Running in $MODE mode"
  case "$MODE" in
    graphical)
      debug_echo "Graphical mode selected"
      # Load configuration
      load_config
      
      # Run graphical installer
      run_graphical_installer
      ;;
    fast)
      debug_echo "Fast mode selected"
      # Set non-interactive mode for fast setup
      INTERACTIVE="false"
      
      # Load configuration
      load_config
      
      # Run fast setup
      run_fast_setup
      ;;
    minimal)
      debug_echo "Minimal mode selected"
      # Set minimal components
      COMPONENTS=("java" "go" "maven")
      debug_echo "Using minimal components: ${COMPONENTS[*]}"
      
      # Load configuration
      load_config
      
      # Run fast setup with minimal components
      run_fast_setup
      ;;
    standard|*)
      debug_echo "Standard mode selected"
      # Load configuration
      load_config
      
      # Standard setup
      local all_passed=true
      local component
      local result=0
      
      for component in "${COMPONENTS[@]}"; do
        debug_echo "Setting up component: $component"
        case "$component" in
          java)
            setup_java 
            result=$?
            debug_echo "setup_java returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          go)
            setup_go
            result=$?
            debug_echo "setup_go returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          python)
            setup_python
            result=$?
            debug_echo "setup_python returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          maven)
            setup_maven
            result=$?
            debug_echo "setup_maven returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          venv)
            setup_python_venv
            result=$?
            debug_echo "setup_python_venv returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          ui)
            setup_ui
            result=$?
            debug_echo "setup_ui returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          config)
            setup_config
            result=$?
            debug_echo "setup_config returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          api)
            setup_api
            result=$?
            debug_echo "setup_api returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          samples)
            setup_java_samples
            result=$?
            debug_echo "setup_java_samples returned: $result"
            [[ $result -ne 0 ]] && all_passed=false
            ;;
          *)
            print_warning "Unknown component: $component"
            ;;
        esac
      done
      
      # Create master activation script
      debug_echo "Creating master activation script"
      create_master_activation
      
      # Test environment unless skipped
      if [[ "$SKIP_TESTS" != "true" ]]; then
        debug_echo "Running environment tests"
        test_environment
        result=$?
        debug_echo "test_environment returned: $result"
        [[ $result -ne 0 ]] && all_passed=false
      else
        debug_echo "Skipping environment tests"
      fi
      
      # Show final message
      if [[ "$all_passed" == true ]]; then
        debug_echo "All components passed"
        display_final_message
        return 0
      else
        echo -e "\033[0;33m! Setup completed with some components failing\033[0m"
        echo -e "\033[0;33m! Please check the logs and fix any issues\033[0m"
        return 1
      fi
      ;;
  esac
  
  # Remove error trap
  trap - ERR
  debug_echo "Main function completed"
}

# Run main function with all arguments
main "$@"