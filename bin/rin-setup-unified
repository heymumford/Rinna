#!/usr/bin/env bash
#
# rin-setup-unified - Unified setup system for Rinna
#
# PURPOSE: Single entry point for all Rinna environment setup, dependency management,
#          and configuration tasks. Consolidates functionality of setup-python.sh,
#          rin-setup, and install-rinna.sh.
#
# Copyright (c) 2025 Eric C. Mumford (@heymumford)
# This file is subject to the terms and conditions defined in
# the LICENSE file, which is part of this source code package.
# (MIT License)
#

set -eo pipefail

# Determine script and project directories
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
RINNA_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_DIR="$HOME/.config/rinna"
CONFIG_FILE="$CONFIG_DIR/environment.conf"
COMMON_DIR="$SCRIPT_DIR/common"

# Source common utilities
source "$COMMON_DIR/rinna_utils.sh"

# Required versions
REQUIRED_JAVA_VERSION="21"
REQUIRED_GO_VERSION="1.21"
REQUIRED_PYTHON_VERSION="3.8"
REQUIRED_MAVEN_VERSION="3.8"

# State variables
INSTALL_MISSING="ask"  # Options: ask, auto, never
MODE="standard"        # Options: standard, graphical, fast, minimal
VERBOSE="false"
FORCE="false"
BACKUP="true"
INTERACTIVE="true"
SKIP_TESTS="false"
SKIP_SYSTEM="false"
PYTHON_INSTALL_OPTIONAL="false"
COMPONENTS=()

# Check if running in a CI environment
if [[ "$(is_ci)" == "true" ]]; then
  # Default to non-interactive mode in CI
  INTERACTIVE="false"
  INSTALL_MISSING="auto"
  MODE="fast"
fi

# Parse command line arguments
parse_args() {
  local arg
  
  while [[ $# -gt 0 ]]; do
    arg="$1"
    case "$arg" in
      install|--install)
        INSTALL_MISSING="auto"
        shift
        ;;
      check|--check)
        INSTALL_MISSING="never"
        shift
        ;;
      config|--config)
        edit_config
        exit 0
        ;;
      --graphical)
        MODE="graphical"
        shift
        ;;
      --fast)
        MODE="fast"
        shift
        ;;
      --minimal)
        MODE="minimal"
        shift
        ;;
      -v|--verbose)
        VERBOSE="true"
        set_log_level "debug"
        shift
        ;;
      -f|--force)
        FORCE="true"
        shift
        ;;
      -y|--yes)
        INTERACTIVE="false"
        shift
        ;;
      --no-backup)
        BACKUP="false"
        shift
        ;;
      --skip-tests)
        SKIP_TESTS="true"
        shift
        ;;
      --skip-system)
        SKIP_SYSTEM="true"
        shift
        ;;
      --all|--optional)
        PYTHON_INSTALL_OPTIONAL="true"
        shift
        ;;
      java|go|python|maven|ui|api|config|venv)
        COMPONENTS+=("$1")
        shift
        ;;
      help|--help|-h)
        show_help
        exit 0
        ;;
      *)
        print_error "Unknown option: $arg"
        show_help
        exit 1
        ;;
    esac
  done
  
  # If no components specified, include all
  if [[ ${#COMPONENTS[@]} -eq 0 ]]; then
    COMPONENTS=("java" "go" "python" "maven" "config")
    
    # Add venv for full setup
    if [[ "$MODE" != "minimal" ]]; then
      COMPONENTS+=("venv" "ui")
    fi
  fi
}

# Display help text
show_help() {
  cat << EOF
${BLUE}${BOLD}rin-setup-unified${NC} - Unified setup system for Rinna

This script provides a single entry point for all Rinna environment setup,
dependency management, and configuration tasks.

Usage: rin-setup-unified [modes] [options] [components]

Modes:
  install             Install missing dependencies without prompting
  check               Check for missing dependencies without installing
  config              Create or edit the configuration file

Options:
  -v, --verbose       Enable verbose output
  -f, --force         Force reinstallation/recreation of components
  -y, --yes           Non-interactive mode (answer yes to all prompts)
  --graphical         Use graphical installer mode
  --fast              Use fast setup mode (minimal output)
  --minimal           Minimal setup (core components only)
  --no-backup         Skip creating backups
  --skip-tests        Skip running tests
  --skip-system       Skip system package installation
  --all, --optional   Install optional dependencies (for Python)

Components:
  java                Java environment setup
  go                  Go environment setup
  python              Python environment setup
  maven               Maven build system setup
  ui                  UI components and configuration
  api                 API service setup
  config              Configuration files and environment
  venv                Python virtual environment

Examples:
  rin-setup-unified                  # Full setup with all components
  rin-setup-unified install          # Install all components without prompting
  rin-setup-unified --graphical      # Run the graphical installer
  rin-setup-unified -f python venv   # Force reinstall Python environment
  rin-setup-unified --minimal        # Minimal setup for core functionality
  rin-setup-unified --fast api go    # Fast setup of API and Go components

Configuration:
  The script uses $CONFIG_FILE for persistent configuration.
  This can be edited directly with the 'config' command.
EOF
}

# Logo and branding
print_logo() {
  clear
  echo -e "${BLUE}"
  echo "        ____  _"
  echo "       / __ \\(_)___  ____  ____ _"
  echo "      / /_/ / / __ \\/ __ \\/ __ \`/"
  echo "     / _, _/ / / / / / / / /_/ /"
  echo "    /_/ |_/_/_/ /_/_/ /_/\\__,_/"
  echo -e "${NC}"
  echo "    Workflow Management System"
  echo "    Setup & Configuration Tool"
  echo ""
}

# Create or update config file
create_config() {
  mkdir -p "$CONFIG_DIR"
  
  cat > "$CONFIG_FILE" << EOF
# Rinna Environment Configuration
# Generated on $(date)
# This file is automatically managed by rin-setup-unified

# Language versions
JAVA_VERSION="$REQUIRED_JAVA_VERSION"
GO_VERSION="$REQUIRED_GO_VERSION"
PYTHON_VERSION="$REQUIRED_PYTHON_VERSION"
MAVEN_VERSION="$REQUIRED_MAVEN_VERSION"

# Path overrides (uncomment and set if needed)
# JAVA_HOME="/path/to/java"
# GOROOT="/path/to/go"
# GOPATH="$HOME/go"
# PYTHON_PATH="/path/to/python"

# Proxy settings (uncomment and set if needed)
# HTTP_PROXY=""
# HTTPS_PROXY=""
# NO_PROXY="localhost,127.0.0.1"

# Package manager preferences
# Preferred package manager for dependency installation
# Options: apt, apt-get, dnf, yum, brew, pkg, auto
PACKAGE_MANAGER="auto"

# Auto-update settings
# Set to true to automatically check for and install updates to dependencies
AUTO_UPDATE="false"

# Install options
# Set to ask (default), auto, or never
INSTALL_MISSING="ask"

# Setup preferences
# Component settings and flags
ENABLE_GRAPHICAL_INSTALLER="true"
PREFER_FAST_MODE="false"
SKIP_TESTS="false"
VERBOSE_OUTPUT="false"
EOF

  chmod 600 "$CONFIG_FILE"
  print_success "Configuration file created at $CONFIG_FILE"
}

# Load config if exists, otherwise create it
load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    print_subheader "Creating configuration file..."
    create_config
  fi
  
  # Source the config file
  source "$CONFIG_FILE"
  
  # Use environment variables if provided, otherwise use config values
  REQUIRED_JAVA_VERSION="${JAVA_VERSION:-$REQUIRED_JAVA_VERSION}"
  REQUIRED_GO_VERSION="${GO_VERSION:-$REQUIRED_GO_VERSION}"
  REQUIRED_PYTHON_VERSION="${PYTHON_VERSION:-$REQUIRED_PYTHON_VERSION}"
  
  # Handle auto package manager detection
  if [[ "$PACKAGE_MANAGER" == "auto" || -z "$PACKAGE_MANAGER" ]]; then
    detect_package_manager
  fi
}

# Detect the appropriate package manager for this system
detect_package_manager() {
  if [[ "$(uname)" == "Darwin" ]]; then
    # macOS
    if command_exists brew; then
      PACKAGE_MANAGER="brew"
    else
      PACKAGE_MANAGER="brew"
      print_warning "Homebrew not found but set as default. Will attempt to install if needed."
    fi
  elif [[ "$(uname)" == "Linux" ]]; then
    # Linux
    if command_exists apt; then
      PACKAGE_MANAGER="apt"
    elif command_exists apt-get; then
      PACKAGE_MANAGER="apt-get"
    elif command_exists dnf; then
      PACKAGE_MANAGER="dnf"
    elif command_exists yum; then
      PACKAGE_MANAGER="yum"
    else
      print_warning "Could not detect package manager. Please install dependencies manually."
      PACKAGE_MANAGER="unknown"
    fi
  elif [[ "$(uname)" == "FreeBSD" ]]; then
    # FreeBSD
    PACKAGE_MANAGER="pkg"
  else
    print_warning "Unsupported operating system: $(uname)"
    PACKAGE_MANAGER="unknown"
  fi
  
  log "info" "Using package manager: $PACKAGE_MANAGER"
}

# Ask user for confirmation
confirm() {
  local prompt="$1"
  local default="${2:-Y}"
  
  if [[ "$INTERACTIVE" == "false" ]]; then
    return 0
  elif [[ "$INSTALL_MISSING" == "never" ]]; then
    return 1
  fi
  
  local options
  if [[ "$default" == "Y" ]]; then
    options="[Y/n]"
  else
    options="[y/N]"
  fi
  
  read -p "$prompt $options " answer
  answer=${answer:-$default}
  
  if [[ "$answer" =~ ^[Yy]$ ]]; then
    return 0
  else
    return 1
  fi
}

# Install packages based on the detected package manager
install_packages() {
  local packages=("$@")
  
  if [[ "$SKIP_SYSTEM" == "true" ]]; then
    print_warning "Skipping system package installation due to --skip-system flag"
    return 0
  fi
  
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      # Ubuntu/Debian
      log "info" "Updating package index..."
      sudo $PACKAGE_MANAGER update -q
      log "info" "Installing packages: ${packages[*]}"
      sudo $PACKAGE_MANAGER install -y "${packages[@]}"
      ;;
    dnf|yum)
      # Fedora/RHEL/CentOS
      log "info" "Installing packages: ${packages[*]}"
      sudo $PACKAGE_MANAGER install -y "${packages[@]}"
      ;;
    brew)
      # macOS (Homebrew)
      if ! command_exists brew; then
        log "info" "Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
      fi
      log "info" "Installing packages: ${packages[*]}"
      brew install "${packages[@]}"
      ;;
    pkg)
      # FreeBSD
      log "info" "Installing packages: ${packages[*]}"
      sudo pkg install -y "${packages[@]}"
      ;;
    *)
      print_error "Unsupported package manager: $PACKAGE_MANAGER"
      return 1
      ;;
  esac
  
  return 0
}

# Add third-party repository
add_repo() {
  local repo="$1"
  local repo_name="${2:-$1}"
  
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      if ! grep -q "^deb.*$repo" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null; then
        log "info" "Adding repository: $repo_name"
        sudo add-apt-repository -y "$repo"
        sudo $PACKAGE_MANAGER update -q
      fi
      ;;
    dnf|yum)
      log "info" "Adding repository: $repo_name"
      sudo $PACKAGE_MANAGER config-manager --add-repo "$repo"
      ;;
    *)
      print_warning "Repository management not supported for $PACKAGE_MANAGER"
      ;;
  esac
}

# Edit config file with default editor or dedicated tool
edit_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    create_config
  fi
  
  # Check if we have the dedicated config tool
  if [[ -x "$SCRIPT_DIR/rin-config" ]]; then
    "$SCRIPT_DIR/rin-config" "view"
    print_subheader "To edit configuration values, use:"
    print_subheader "  $SCRIPT_DIR/rin-config set <key> <value>"
    
    if confirm "Would you like to create user-specific config file for this environment?"; then
      "$SCRIPT_DIR/rin-config" "create-user" "$CURRENT_ENV"
    fi
    
    return 0
  else
    # Fall back to basic editor
    if [[ -n "$EDITOR" ]]; then
      $EDITOR "$CONFIG_FILE"
    elif command_exists nano; then
      nano "$CONFIG_FILE"
    elif command_exists vim; then
      vim "$CONFIG_FILE"
    else
      print_error "No text editor found. Please edit $CONFIG_FILE manually."
    fi
    
    return 0
  fi
}

#
# Component-specific installation functions
#

# Setup Java environment
setup_java() {
  print_header "Setting up Java environment..."
  
  # Check if Java is already installed with the correct version
  if check_java_version "$REQUIRED_JAVA_VERSION"; then
    print_success "Java $REQUIRED_JAVA_VERSION is already installed"
    return 0
  fi
  
  log "info" "Java $REQUIRED_JAVA_VERSION not found or version mismatch"
  
  # Ask for confirmation if interactive
  if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Java ${REQUIRED_JAVA_VERSION}?"; then
    print_warning "Skipping Java installation"
    return 1
  fi
  
  # Install Java based on the package manager
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      # Ubuntu/Debian approach
      if ! command_exists add-apt-repository; then
        install_packages software-properties-common
      fi
      
      add_repo "ppa:openjdk-r/ppa" "OpenJDK PPA"
      install_packages "openjdk-${REQUIRED_JAVA_VERSION}-jdk"
      ;;
    dnf)
      # Fedora approach
      install_packages "java-${REQUIRED_JAVA_VERSION}-openjdk-devel"
      ;;
    yum)
      # RHEL/CentOS approach
      install_packages "java-${REQUIRED_JAVA_VERSION}-openjdk-devel"
      ;;
    brew)
      # macOS approach
      install_packages "openjdk@${REQUIRED_JAVA_VERSION}"
      # Create symlink in /usr/local/opt
      log "info" "Creating symlink for Java..."
      sudo ln -sfn "$(brew --prefix)/opt/openjdk@${REQUIRED_JAVA_VERSION}/libexec/openjdk.jdk" /Library/Java/JavaVirtualMachines/openjdk-${REQUIRED_JAVA_VERSION}.jdk
      ;;
    *)
      print_error "Automatic Java installation not supported for $PACKAGE_MANAGER"
      print_step "Please install Java $REQUIRED_JAVA_VERSION manually"
      return 1
      ;;
  esac
  
  # Create/update the activate-java.sh script
  cat > "$RINNA_DIR/activate-java.sh" << EOF
#!/usr/bin/env bash
# Java environment setup for Rinna
# Generated by rin-setup-unified on $(date)

# Java Home setup
if [[ -d "/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk-amd64" ]]; then
  export JAVA_HOME="/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk-amd64"
elif [[ -d "/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk" ]]; then
  export JAVA_HOME="/usr/lib/jvm/java-${REQUIRED_JAVA_VERSION}-openjdk"
elif [[ -d "/Library/Java/JavaVirtualMachines/openjdk-${REQUIRED_JAVA_VERSION}.jdk/Contents/Home" ]]; then
  export JAVA_HOME="/Library/Java/JavaVirtualMachines/openjdk-${REQUIRED_JAVA_VERSION}.jdk/Contents/Home"
elif [[ -d "$HOME/.jdks/openjdk-${REQUIRED_JAVA_VERSION}" ]]; then
  export JAVA_HOME="$HOME/.jdks/openjdk-${REQUIRED_JAVA_VERSION}"
elif [[ -d "\$PROGRAMFILES/Java/jdk-${REQUIRED_JAVA_VERSION}" ]]; then
  export JAVA_HOME="\$PROGRAMFILES/Java/jdk-${REQUIRED_JAVA_VERSION}"
elif [[ -d "\$PROGRAMFILES/Eclipse Adoptium/jdk-${REQUIRED_JAVA_VERSION}" ]]; then
  export JAVA_HOME="\$PROGRAMFILES/Eclipse Adoptium/jdk-${REQUIRED_JAVA_VERSION}"
fi

if [[ -n "\$JAVA_HOME" ]]; then
  export PATH="\$JAVA_HOME/bin:\$PATH"
  echo "Using Java \$JAVA_HOME"
  java -version
else
  echo "WARNING: Could not locate Java ${REQUIRED_JAVA_VERSION}"
  echo "Please set JAVA_HOME manually if needed"
fi
EOF
  
  chmod +x "$RINNA_DIR/activate-java.sh"
  print_success "Created Java activation script: activate-java.sh"
  
  # Source the script to set up the environment
  source "$RINNA_DIR/activate-java.sh"
  
  # Verify installation
  if check_java_version "$REQUIRED_JAVA_VERSION"; then
    print_success "Java $REQUIRED_JAVA_VERSION installation successful"
    return 0
  else
    print_error "Java installation failed or version requirements not met"
    return 1
  fi
}

# Setup Go environment
setup_go() {
  print_header "Setting up Go environment..."
  
  # Check if Go is already installed with the correct version
  if check_go_version "$REQUIRED_GO_VERSION"; then
    print_success "Go $REQUIRED_GO_VERSION is already installed"
    return 0
  fi
  
  log "info" "Go $REQUIRED_GO_VERSION not found or version mismatch"
  
  # Ask for confirmation if interactive
  if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Go ${REQUIRED_GO_VERSION}?"; then
    print_warning "Skipping Go installation"
    return 1
  fi
  
  # Install Go based on the package manager
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      # Check if golang-go is new enough in the default repos
      if apt-cache policy golang-go | grep -q "$REQUIRED_GO_VERSION"; then
        install_packages golang-go
      else
        # Add the longsleep/golang-backports PPA for newer Go versions
        if ! command_exists add-apt-repository; then
          install_packages software-properties-common
        fi
        
        add_repo "ppa:longsleep/golang-backports" "Go Backports PPA"
        install_packages "golang-${REQUIRED_GO_VERSION}"
      fi
      ;;
    dnf|yum)
      install_packages "golang"
      # Check if the installed version meets the requirement
      if ! check_go_version "$REQUIRED_GO_VERSION"; then
        # Alternative: download and install from golang.org
        log "info" "Installing Go from golang.org..."
        local arch=$(uname -m)
        [[ "$arch" == "x86_64" ]] && arch="amd64"
        
        local go_tar="go${REQUIRED_GO_VERSION}.linux-${arch}.tar.gz"
        local download_url="https://golang.org/dl/${go_tar}"
        
        mkdir -p "$HOME/go_install"
        curl -L "$download_url" -o "$HOME/go_install/${go_tar}"
        # Safely remove Go installation - don't use rm -rf directly on /usr paths
        if [ -d "/usr/local/go" ]; then
          sudo rm -rf "/usr/local/go"
        fi
        sudo tar -C /usr/local -xzf "$HOME/go_install/${go_tar}"
        rm -rf "$HOME/go_install"
        
        # Add to PATH in profile
        if [[ ! -f "$HOME/.profile" || ! $(grep -q "GOPATH" "$HOME/.profile") ]]; then
          echo 'export PATH=$PATH:/usr/local/go/bin' >> "$HOME/.profile"
          echo 'export GOPATH=$HOME/go' >> "$HOME/.profile"
          echo 'export PATH=$PATH:$GOPATH/bin' >> "$HOME/.profile"
        fi
        
        export PATH=$PATH:/usr/local/go/bin
        export GOPATH=$HOME/go
        export PATH=$PATH:$GOPATH/bin
      fi
      ;;
    brew)
      install_packages go
      ;;
    *)
      print_error "Automatic Go installation not supported for $PACKAGE_MANAGER"
      print_step "Please install Go $REQUIRED_GO_VERSION manually"
      return 1
      ;;
  esac
  
  # Create/update the activate-go.sh script
  cat > "$RINNA_DIR/activate-go.sh" << EOF
#!/usr/bin/env bash
# Go environment setup for Rinna
# Generated by rin-setup-unified on $(date)

# Go environment setup
if [[ -d "/usr/local/go" ]]; then
  export GOROOT="/usr/local/go"
  export PATH="\$GOROOT/bin:\$PATH"
elif command -v go &>/dev/null; then
  export GOROOT="\$(go env GOROOT 2>/dev/null)"
fi

# Set GOPATH if not already set
if [[ -z "\$GOPATH" ]]; then
  export GOPATH="\$HOME/go"
  mkdir -p "\$GOPATH"
fi

# Add GOPATH/bin to PATH
export PATH="\$PATH:\$GOPATH/bin"

# Set project-specific Go paths
export RINNA_GO_DIR="\$RINNA_DIR/api"
export GO111MODULE=on

echo "Go environment configured:"
echo "  GOROOT: \$GOROOT"
echo "  GOPATH: \$GOPATH"
EOF
  
  chmod +x "$RINNA_DIR/activate-go.sh"
  print_success "Created Go activation script: activate-go.sh"
  
  # Source the script to set up the environment
  source "$RINNA_DIR/activate-go.sh"
  
  # Verify installation
  if check_go_version "$REQUIRED_GO_VERSION"; then
    print_success "Go $REQUIRED_GO_VERSION installation successful"
    return 0
  else
    print_error "Go installation failed or version requirements not met"
    return 1
  fi
}

# Setup Python environment (base system Python)
setup_python() {
  print_header "Setting up Python environment..."
  
  # Find the Python executable
  local python_cmd=""
  if command_exists python3; then
    python_cmd="python3"
  elif command_exists python; then
    if python --version 2>&1 | grep -q "Python 3"; then
      python_cmd="python"
    fi
  fi
  
  if [[ -z "$python_cmd" ]]; then
    print_error "Python 3 is not installed"
    
    # Ask for confirmation if interactive
    if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Python ${REQUIRED_PYTHON_VERSION}?"; then
      print_warning "Skipping Python installation"
      return 1
    fi
    
    # Install Python based on package manager
    case "$PACKAGE_MANAGER" in
      apt|apt-get)
        install_packages python3 python3-pip python3-venv python3-dev
        ;;
      dnf|yum)
        install_packages python3 python3-pip python3-devel
        ;;
      brew)
        install_packages python
        ;;
      *)
        print_error "Automatic Python installation not supported for $PACKAGE_MANAGER"
        print_step "Please install Python $REQUIRED_PYTHON_VERSION manually"
        return 1
        ;;
    esac
    
    # Find Python again after installation
    if command_exists python3; then
      python_cmd="python3"
    elif command_exists python && python --version 2>&1 | grep -q "Python 3"; then
      python_cmd="python"
    else
      print_error "Python installation failed"
      return 1
    fi
  fi
  
  # Check Python version
  local py_version
  py_version=$($python_cmd --version 2>&1 | sed 's/Python //')
  local py_major=$(echo "$py_version" | cut -d. -f1)
  local py_minor=$(echo "$py_version" | cut -d. -f2)
  
  local req_major=$(echo "$REQUIRED_PYTHON_VERSION" | cut -d. -f1)
  local req_minor=$(echo "$REQUIRED_PYTHON_VERSION" | cut -d. -f2)
  
  if [[ "$py_major" -lt "$req_major" || ("$py_major" -eq "$req_major" && "$py_minor" -lt "$req_minor") ]]; then
    print_error "Python $REQUIRED_PYTHON_VERSION or higher is required (found $py_version)"
    
    # Ask for confirmation if interactive
    if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Python ${REQUIRED_PYTHON_VERSION}?"; then
      print_warning "Skipping Python upgrade"
      return 1
    fi
    
    # Attempt to upgrade Python (this is platform-dependent)
    case "$PACKAGE_MANAGER" in
      apt|apt-get)
        # Try using deadsnakes PPA for newer Python versions
        if ! command_exists add-apt-repository; then
          install_packages software-properties-common
        fi
        
        add_repo "ppa:deadsnakes/ppa" "Deadsnakes PPA"
        install_packages "python${REQUIRED_PYTHON_VERSION}" "python${REQUIRED_PYTHON_VERSION}-venv" "python${REQUIRED_PYTHON_VERSION}-dev"
        ;;
      dnf)
        # Fedora may have newer Pythons available
        install_packages "python${REQUIRED_PYTHON_VERSION}" "python${REQUIRED_PYTHON_VERSION}-devel"
        ;;
      brew)
        install_packages "python@${REQUIRED_PYTHON_VERSION}"
        ;;
      *)
        print_error "Python version upgrade not supported automatically"
        print_step "Please upgrade Python to $REQUIRED_PYTHON_VERSION or higher manually"
        return 1
        ;;
    esac
    
    # Check if Python is installed with correct version
    if command_exists "python${req_major}.${req_minor}"; then
      python_cmd="python${req_major}.${req_minor}"
    elif command_exists python3 && python3 --version 2>&1 | grep -q "Python ${req_major}\.${req_minor}"; then
      python_cmd="python3"
    else
      print_error "Python upgrade failed"
      return 1
    fi
  fi
  
  # Check for venv module
  if ! $python_cmd -c "import venv" &> /dev/null; then
    print_error "Python venv module is not available"
    
    # Ask for confirmation if interactive
    if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Python venv module?"; then
      print_warning "Skipping venv module installation"
      return 1
    fi
    
    case "$PACKAGE_MANAGER" in
      apt|apt-get)
        log "info" "Installing python3-venv..."
        install_packages python3-venv
        ;;
      dnf|yum)
        log "info" "Installing python3-devel..."
        install_packages python3-devel
        ;;
      brew)
        print_warning "On macOS, venv should be included with Python"
        print_step "If issues persist, try reinstalling Python with: brew reinstall python"
        ;;
      *)
        print_error "Automatic venv installation not supported for $PACKAGE_MANAGER"
        print_step "Please install Python venv module manually"
        return 1
        ;;
    esac
  fi
  
  # Create/update the activate-python.sh script (for system Python, not venv)
  cat > "$RINNA_DIR/activate-system-python.sh" << EOF
#!/usr/bin/env bash
# System Python environment setup for Rinna
# Generated by rin-setup-unified on $(date)

# Set Python environment variables
export PYTHONPATH="\$RINNA_DIR:\$RINNA_DIR/python"

# Use the correct Python version
if command -v python${req_major}.${req_minor} &>/dev/null; then
  alias python=python${req_major}.${req_minor}
  alias pip=pip${req_major}.${req_minor}
else
  # Fall back to python3
  alias python=python3
  alias pip=pip3
fi

# Add local bin directory to PATH if it exists
if [[ -d "\$HOME/.local/bin" ]]; then
  export PATH="\$HOME/.local/bin:\$PATH"
fi

echo "System Python environment configured"
python --version
EOF
  
  chmod +x "$RINNA_DIR/activate-system-python.sh"
  print_success "Created Python activation script: activate-system-python.sh"
  
  print_success "Python $py_version setup complete"
  return 0
}

# Setup Maven build system
setup_maven() {
  print_header "Setting up Maven build system..."
  
  # Check if Maven is already installed 
  if command_exists mvn; then
    local mvn_version
    mvn_version=$(mvn --version | grep -oE "Apache Maven [0-9]+\.[0-9]+\.[0-9]+" | cut -d' ' -f3)
    print_success "Maven $mvn_version is already installed"
    return 0
  fi
  
  log "info" "Maven not found"
  
  # Ask for confirmation if interactive
  if [[ "$INSTALL_MISSING" == "ask" ]] && ! confirm "Install Maven?"; then
    print_warning "Skipping Maven installation"
    return 1
  fi
  
  # Install Maven based on the package manager
  case "$PACKAGE_MANAGER" in
    apt|apt-get)
      install_packages maven
      ;;
    dnf|yum)
      install_packages maven
      ;;
    brew)
      install_packages maven
      ;;
    *)
      print_error "Automatic Maven installation not supported for $PACKAGE_MANAGER"
      print_step "Please install Maven manually"
      return 1
      ;;
  esac
  
  # Verify installation
  if command_exists mvn; then
    local mvn_version
    mvn_version=$(mvn --version | grep -oE "Apache Maven [0-9]+\.[0-9]+\.[0-9]+" | cut -d' ' -f3)
    print_success "Maven $mvn_version installation successful"
    return 0
  else
    print_error "Maven installation failed"
    return 1
  fi
}

# Create Python virtual environment
setup_python_venv() {
  print_header "Setting up Python virtual environment..."
  
  # Constants
  local venv_dir="$RINNA_DIR/.venv"
  local requirements_file="$RINNA_DIR/requirements.txt"
  
  # Check if venv exists and force flag is set
  if [[ -d "$venv_dir" ]]; then
    if [[ "$FORCE" == "true" ]]; then
      log "info" "Removing existing virtual environment"
      rm -rf "$venv_dir"
    else
      print_success "Virtual environment already exists at $venv_dir"
      
      # Create activation script regardless
      create_python_activation_script "$venv_dir"
      return 0
    fi
  fi
  
  # Find Python executable
  local python_cmd
  if command_exists python3; then
    python_cmd="python3"
  elif command_exists python && python --version 2>&1 | grep -q "Python 3"; then
    python_cmd="python"
  else
    print_error "Python 3 not found"
    return 1
  fi
  
  # Create virtual environment
  log "info" "Creating virtual environment at $venv_dir"
  if [[ "$VERBOSE" == "true" ]]; then
    $python_cmd -m venv "$venv_dir"
  else
    $python_cmd -m venv "$venv_dir" &> /dev/null
  fi
  
  if [[ ! -f "$venv_dir/bin/activate" ]]; then
    print_error "Failed to create virtual environment"
    return 1
  fi
  
  print_success "Virtual environment created successfully"
  
  # Use pip from venv
  local pip="$venv_dir/bin/pip"
  
  # Update pip to latest version
  log "info" "Updating pip to latest version"
  if [[ "$VERBOSE" == "true" ]]; then
    "$pip" install --upgrade pip
  else
    "$pip" install --upgrade pip &> /dev/null
  fi
  
  # Check if requirements file exists
  if [[ ! -f "$requirements_file" ]]; then
    log "warning" "Requirements file not found at $requirements_file"
    
    # Create a basic requirements file
    cat > "$requirements_file" << EOF
# Rinna Python dependencies
# Generated by rin-setup-unified on $(date)

# Core dependencies
pyyaml>=6.0
requests>=2.28.0
pytest>=7.0.0
pytest-cov>=4.0.0

# Optional dependencies
diagrams>=0.23.0  # (optional) For generating architecture diagrams
black>=23.0.0     # (optional) Code formatter
ruff>=0.0.260     # (optional) Linter
mypy>=1.0.0       # (optional) Type checker
bandit>=1.7.5     # (optional) Security checker
EOF
    
    log "info" "Created basic requirements.txt file"
  fi
  
  # Install dependencies from requirements.txt
  log "info" "Installing Python dependencies"
  
  # Install wheel first to help with binary packages
  if [[ "$VERBOSE" == "true" ]]; then
    "$pip" install wheel
  else
    "$pip" install wheel &> /dev/null
  fi

  # Parse requirements.txt to separate regular and optional dependencies
  local temp_req=$(mktemp)
  
  # Extract non-optional requirements
  grep -v "(optional)" "$requirements_file" | grep -v "^#" | grep -v "^$" > "$temp_req"
  
  local active_req
  if [[ "$PYTHON_INSTALL_OPTIONAL" == "true" ]]; then
    # If installing optional deps, use the original file
    active_req="$requirements_file"
    log "info" "Will install ALL dependencies including optional ones"
  else
    # Otherwise use the filtered file
    active_req="$temp_req"
    log "info" "Will install only required dependencies (use --all for optional deps)"
  fi
  
  # Install dependencies
  if [[ "$VERBOSE" == "true" ]]; then
    "$pip" install -r "$active_req" --upgrade
  else
    # Show a progress message since this might take a while
    echo -n "Installing packages..."
    "$pip" install -r "$active_req" --upgrade &> /dev/null || {
      echo " failed!"
      print_error "Failed to install dependencies. Run with --verbose to see the errors."
      rm -f "$temp_req"
      return 1
    }
    echo " done!"
  fi
  
  # Cleanup temporary file
  rm -f "$temp_req"
  
  # Check for system dependencies that might be needed
  if [[ "$PYTHON_INSTALL_OPTIONAL" == "true" && "$SKIP_SYSTEM" != "true" ]]; then
    if grep -q "diagrams" "$requirements_file"; then
      if ! command_exists dot; then
        log "info" "Installing graphviz for diagrams package"
        install_packages graphviz
      fi
    fi
  fi
  
  # Add version file to virtual environment
  update_venv_version "$venv_dir"
  
  # Create activation script
  create_python_activation_script "$venv_dir"
  
  # Create .env file for VS Code and other tools
  create_env_file "$venv_dir"
  
  print_success "Python virtual environment setup complete"
  return 0
}

# Update virtual environment version information
update_venv_version() {
  local venv_dir="$1"
  
  # Get project version from version.properties
  local version
  version=$(get_version)
  
  # Create version file in virtual environment
  echo "$version" > "$venv_dir/version"
  
  # Create a Python module with version info
  local py_sitepackages
  py_sitepackages=$($venv_dir/bin/python -c "import site; print(site.getsitepackages()[0])")
  local venv_info_dir="$py_sitepackages/rinna_venv_info"
  mkdir -p "$venv_info_dir"
  
  # Create __init__.py
  cat > "$venv_info_dir/__init__.py" << EOF
"""Rinna virtual environment information."""

VERSION = "$version"
CREATION_DATE = "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
PYTHON_VERSION = "$($venv_dir/bin/python --version 2>&1 | cut -d' ' -f2)"

def get_version():
    """Return the Rinna project version."""
    return VERSION

def get_info():
    """Return dictionary with virtual environment information."""
    return {
        "version": VERSION,
        "creation_date": CREATION_DATE,
        "python_version": PYTHON_VERSION,
    }

def print_info():
    """Print virtual environment information."""
    print(f"Rinna Virtual Environment")
    print(f"Version: {VERSION}")
    print(f"Created: {CREATION_DATE}")
    print(f"Python:  {PYTHON_VERSION}")
EOF

  # Create __main__.py for direct module execution
  cat > "$venv_info_dir/__main__.py" << EOF
"""Main entry point for rinna_venv_info package."""

from rinna_venv_info import print_info

# Print environment info when module is executed directly
print_info()
EOF
  
  log "info" "Created Python version module in virtual environment"
}

# Create Python virtual environment activation script
create_python_activation_script() {
  local venv_dir="$1"
  local activate_script="$RINNA_DIR/activate-python.sh"
  
  cat > "$activate_script" << EOF
#!/usr/bin/env bash
#
# activate-python.sh - Activate Python virtual environment for Rinna
# Generated by rin-setup-unified on $(date)
#

# Activate the virtual environment
if [[ -f "$venv_dir/bin/activate" ]]; then
    source "$venv_dir/bin/activate"
    
    # Set project environment variables
    export RINNA_ROOT="$RINNA_DIR"
    export RINNA_VERSION=\$(cat "$venv_dir/version" 2>/dev/null || echo "unknown")
    export PYTHONPATH="\$RINNA_ROOT:\$RINNA_ROOT/python"
    
    # Show version info
    if python -c "import rinna_venv_info" &>/dev/null; then
        python -m rinna_venv_info
    else
        echo "Rinna Python environment activated (version \$RINNA_VERSION)"
    fi
    
    echo "Run 'deactivate' to exit the virtual environment"
else
    echo "Error: Virtual environment not found at $venv_dir"
    echo "Run 'bin/rin-setup-unified python venv' to create it"
    return 1
fi
EOF
  
  chmod +x "$activate_script"
  print_success "Created activation script at $activate_script"
}

# Create .env file for VS Code and other tools
create_env_file() {
  local venv_dir="$1"
  local env_file="$RINNA_DIR/.env"
  
  cat > "$env_file" << EOF
# Python environment variables for Rinna
# Generated by rin-setup-unified on $(date)
PYTHONPATH=${RINNA_DIR}:${RINNA_DIR}/python
VIRTUAL_ENV=${venv_dir}
EOF
  
  # For VS Code, also create settings if they don't exist
  local vscode_dir="$RINNA_DIR/.vscode"
  local settings_file="$vscode_dir/settings.json"
  
  if [[ ! -d "$vscode_dir" ]]; then
    mkdir -p "$vscode_dir"
  fi
  
  if [[ ! -f "$settings_file" ]]; then
    cat > "$settings_file" << EOF
{
    "python.defaultInterpreterPath": "${venv_dir}/bin/python",
    "python.analysis.extraPaths": [
        "${RINNA_DIR}",
        "${RINNA_DIR}/python"
    ],
    "python.testing.pytestEnabled": true,
    "python.linting.enabled": true,
    "java.configuration.updateBuildConfiguration": "automatic",
    "go.toolsEnvVars": {
        "GO111MODULE": "on"
    }
}
EOF
    log "info" "Created VS Code settings at $settings_file"
  fi
  
  log "info" "Created .env file at $env_file"
}

# Setup UI configuration (minimal/text UI)
setup_ui() {
  print_header "Setting up UI configuration..."
  
  # Create .rinna directory in home for user-specific settings
  mkdir -p "$HOME/.rinna"
  
  # Create empty user configuration file if it doesn't exist
  local user_config="$HOME/.rinna/config.yaml"
  if [[ ! -f "$user_config" ]]; then
    cat > "$user_config" << EOF
# Rinna User Configuration
# Generated by rin-setup-unified on $(date)

# User interface settings
ui:
  theme: default
  colors: true
  unicode: true
  verbose: false

# Default settings
defaults:
  project: default
  workflow: standard
  editor: auto

# Paths
paths:
  workspace: ~/rinna-workspace
  data: ~/.rinna/data
  logs: ~/.rinna/logs
  cache: ~/.rinna/cache

# Tools
tools:
  editor: ${EDITOR:-auto}
  browser: auto
  diff: auto
EOF
    
    print_success "Created user configuration at $user_config"
  else
    log "info" "User configuration already exists at $user_config"
  fi
  
  # Ensure bin directory scripts are executable
  log "info" "Ensuring CLI scripts are executable..."
  
  local bin_files=(
    "$RINNA_DIR/bin/rin"
    "$RINNA_DIR/bin/rin-build"
    "$RINNA_DIR/bin/rin-version"
    "$RINNA_DIR/bin/rin-setup"
    "$RINNA_DIR/bin/rin-setup-unified"
    "$RINNA_DIR/bin/rin-doc"
    "$RINNA_DIR/bin/setup-python.sh"
    "$RINNA_DIR/bin/install-rinna.sh"
  )
  
  for file in "${bin_files[@]}"; do
    if [[ -f "$file" ]]; then
      chmod +x "$file"
      log "info" "Made executable: $(basename "$file")"
    fi
  done
  
  # Create symbolic links in user's bin directory if possible
  local user_bin="$HOME/.local/bin"
  if [[ ! -d "$user_bin" ]]; then
    mkdir -p "$user_bin"
  fi
  
  if [[ -d "$user_bin" ]]; then
    if [[ ! -L "$user_bin/rin" || $(readlink -f "$user_bin/rin") != "$RINNA_DIR/bin/rin" ]]; then
      ln -sf "$RINNA_DIR/bin/rin" "$user_bin/rin"
      print_success "Created symlink in $user_bin/rin"
    fi
    
    # Add bin directory to PATH if not already present
    if ! echo "$PATH" | grep -q "$user_bin"; then
      print_warning "Please add $user_bin to your PATH"
      print_step "Add this line to your shell profile (~/.bashrc, ~/.zshrc, etc.):"
      print_step "export PATH=\"$user_bin:\$PATH\""
    fi
  fi
  
  print_success "UI configuration complete"
  return 0
}

# Test the entire environment
test_environment() {
  if [[ "$SKIP_TESTS" == "true" ]]; then
    log "info" "Skipping environment tests (--skip-tests flag provided)"
    return 0
  fi
  
  print_header "Testing Rinna environment..."
  local all_passed=true
  
  # Test Java build if available
  if command_exists java && command_exists mvn; then
    log "info" "Testing Java build..."
    if ! cd "$RINNA_DIR" && mvn compile -DskipTests -P skip-quality -q; then
      print_error "Java build test failed"
      all_passed=false
    else
      print_success "Java build test passed"
    fi
  fi
  
  # Test Go build if available
  if command_exists go; then
    log "info" "Testing Go build..."
    if [[ -d "$RINNA_DIR/api" && -f "$RINNA_DIR/api/go.mod" ]]; then
      if ! cd "$RINNA_DIR/api" && go build ./cmd/healthcheck; then
        print_error "Go build test failed"
        all_passed=false
      else
        print_success "Go build test passed"
      fi
    else
      log "warning" "Skipping Go build test (missing go.mod)"
    fi
  fi
  
  # Test Python if available
  if command_exists python3; then
    log "info" "Testing Python..."
    if ! python3 -c "print('Python is working')" &>/dev/null; then
      print_error "Python test failed"
      all_passed=false
    else
      print_success "Python test passed"
    fi
  fi
  
  # Return to project root
  cd "$RINNA_DIR"
  
  if [[ "$all_passed" == true ]]; then
    print_success "All environment tests passed!"
    return 0
  else
    print_warning "Some environment tests failed"
    return 1
  fi
}

# Run the graphical installer
run_graphical_installer() {
  print_header "Running graphical installer..."
  
  local installer_script="$RINNA_DIR/bin/install-rinna.sh"
  
  if [[ ! -x "$installer_script" ]]; then
    print_error "Graphical installer not found or not executable: $installer_script"
    return 1
  fi
  
  # Run installer with appropriate options
  if [[ "$MODE" == "fast" ]]; then
    "$installer_script" --fast
  else
    "$installer_script"
  fi
  
  return 0
}

# Fast mode setup
run_fast_setup() {
  print_header "Running fast setup..."
  
  # Set up components in sequence
  local results=()
  local component
  
  for component in "${COMPONENTS[@]}"; do
    case "$component" in
      java)
        setup_java
        results+=($?)
        ;;
      go)
        setup_go
        results+=($?)
        ;;
      python)
        setup_python
        results+=($?)
        ;;
      maven)
        setup_maven
        results+=($?)
        ;;
      config)
        load_config
        results+=($?)
        ;;
      venv)
        setup_python_venv
        results+=($?)
        ;;
      ui)
        setup_ui
        results+=($?)
        ;;
      *)
        print_warning "Unknown component: $component"
        ;;
    esac
  done
  
  # Test the environment if requested
  if [[ "$SKIP_TESTS" != "true" ]]; then
    test_environment
    results+=($?)
  fi
  
  # Count failures
  local failures=0
  for result in "${results[@]}"; do
    ((failures += result))
  done
  
  if [[ $failures -eq 0 ]]; then
    print_success "Fast setup completed successfully"
    return 0
  else
    print_warning "Fast setup completed with $failures failures"
    return 1
  fi
}

# Create a master activation script that sources all component-specific scripts
create_master_activation() {
  print_header "Creating master activation script..."
  
  local activate_script="$RINNA_DIR/activate-rinna.sh"
  
  cat > "$activate_script" << EOF
#!/usr/bin/env bash
#
# activate-rinna.sh - Master activation script for Rinna environment
# Generated by rin-setup-unified on $(date)
#

# Save current directory
export RINNA_DIR="$(cd "$RINNA_DIR" && pwd)"
export RINNA_VERSION="$(get_version)"

# Function to load component if available
load_component() {
  local script="\$1"
  local name="\$2"
  
  if [[ -f "\$script" ]]; then
    echo "Loading \$name environment..."
    source "\$script"
    return 0
  fi
  return 1
}

# Clear any existing Rinna environment
# This prevents stacking environments if sourced multiple times
if [[ -n "\$RINNA_ENV_ACTIVE" ]]; then
  echo "Refreshing Rinna environment..."
  # If we had a Python venv activated, deactivate it
  if [[ -n "\$VIRTUAL_ENV" ]]; then
    deactivate 2>/dev/null || true
  fi
fi

# Load component configurations
load_component "\$RINNA_DIR/activate-java.sh" "Java"
load_component "\$RINNA_DIR/activate-go.sh" "Go"

# Python environment - prefer venv but fall back to system
if [[ -f "\$RINNA_DIR/activate-python.sh" ]]; then
  load_component "\$RINNA_DIR/activate-python.sh" "Python virtual environment"
else
  load_component "\$RINNA_DIR/activate-system-python.sh" "System Python"
fi

# Mark environment as active
export RINNA_ENV_ACTIVE="true"

# Add bin directory to path
export PATH="\$RINNA_DIR/bin:\$PATH"

# Display environment information
echo ""
echo "Rinna environment activated (version \$RINNA_VERSION)"
echo "Run 'deactivate-rinna' to exit this environment"

# Define deactivation function
deactivate-rinna() {
  if [[ -n "\$VIRTUAL_ENV" ]]; then
    deactivate
  fi
  
  # Restore PATH (remove our bin directory)
  export PATH="\${PATH//\$RINNA_DIR\/bin:/}"
  
  # Unset variables
  unset RINNA_ENV_ACTIVE
  unset RINNA_DIR
  unset deactivate-rinna
  
  echo "Rinna environment deactivated"
}
EOF
  
  chmod +x "$activate_script"
  print_success "Created master activation script at $activate_script"
}

# Display final message
display_final_message() {
  print_header "Setup Complete!"
  echo ""
  echo "Rinna has been set up successfully."
  echo ""
  echo "To activate the full Rinna environment, run:"
  echo "  source $RINNA_DIR/activate-rinna.sh"
  echo ""
  echo "For component-specific environments:"
  echo "  Java:   source $RINNA_DIR/activate-java.sh"
  echo "  Go:     source $RINNA_DIR/activate-go.sh"
  echo "  Python: source $RINNA_DIR/activate-python.sh"
  echo ""
  echo "To start using Rinna, run:"
  echo "  bin/rin --help"
  echo ""
}

# Main function
main() {
  # Parse command line arguments
  parse_args "$@"
  
  # Show logo
  print_logo
  
  # Choose setup mode
  case "$MODE" in
    graphical)
      # Load configuration
      load_config
      
      # Run graphical installer
      run_graphical_installer
      ;;
    fast)
      # Set non-interactive mode for fast setup
      INTERACTIVE="false"
      
      # Load configuration
      load_config
      
      # Run fast setup
      run_fast_setup
      ;;
    minimal)
      # Set minimal components
      COMPONENTS=("java" "go" "maven")
      
      # Load configuration
      load_config
      
      # Run fast setup with minimal components
      run_fast_setup
      ;;
    standard|*)
      # Load configuration
      load_config
      
      # Standard setup
      local all_passed=true
      local component
      
      for component in "${COMPONENTS[@]}"; do
        case "$component" in
          java)
            setup_java || all_passed=false
            ;;
          go)
            setup_go || all_passed=false
            ;;
          python)
            setup_python || all_passed=false
            ;;
          maven)
            setup_maven || all_passed=false
            ;;
          venv)
            setup_python_venv || all_passed=false
            ;;
          ui)
            setup_ui || all_passed=false
            ;;
          *)
            print_warning "Unknown component: $component"
            ;;
        esac
      done
      
      # Create master activation script
      create_master_activation
      
      # Test environment unless skipped
      if [[ "$SKIP_TESTS" != "true" ]]; then
        test_environment || all_passed=false
      fi
      
      # Show final message
      if [[ "$all_passed" == true ]]; then
        display_final_message
        return 0
      else
        print_warning "Setup completed with some components failing"
        print_warning "Please check the logs and fix any issues"
        return 1
      fi
      ;;
  esac
}

# Run main function with all arguments
main "$@"