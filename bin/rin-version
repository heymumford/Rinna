#!/usr/bin/env bash

#
# rin-version - Streamlined Rinna version management utility
#
# Copyright (c) 2025 Eric C. Mumford (@heymumford)
# This file is subject to the terms and conditions defined in
# the LICENSE file, which is part of this source code package.
# (MIT License)
#

set -e

# Constants
RINNA_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
VERSION_FILE="$RINNA_DIR/version.properties"
README_FILE="$RINNA_DIR/README.md"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# UI Functions
print_header() { echo -e "${BLUE}$1${NC}"; }
print_success() { echo -e "${GREEN}$1${NC}"; }
print_warning() { echo -e "${YELLOW}$1${NC}"; }
print_error() { echo -e "${RED}$1${NC}"; exit 1; }

# Helper Functions
get_version() {
  grep -m 1 "^version=" "$VERSION_FILE" | cut -d'=' -f2
}

get_property() {
  local prop="$1"
  grep -m 1 "^$prop=" "$VERSION_FILE" | cut -d'=' -f2
}

increment_version() {
  local version="$1" index="$2"
  IFS='.' read -r -a parts <<< "$version"
  
  # Increment the specified part
  parts[$index]=$((parts[$index] + 1))
  
  # Reset lower parts to 0
  for ((i=index+1; i<${#parts[@]}; i++)); do
    parts[$i]=0
  done
  
  echo "${parts[0]}.${parts[1]}.${parts[2]}"
}

# Determine if a version should have a GitHub release
# Based on: major/minor versions always get releases,
# patch versions only get releases for significant changes or if marked as RELEASE
should_create_github_release() {
  local version="$1" release_type="$2"
  IFS='.' read -r major minor patch <<< "$version"
  
  # Always create releases for major and minor versions
  if [[ "$patch" == "0" ]]; then
    return 0 # true
  fi
  
  # Create releases for explicitly marked RELEASE versions
  if [[ "$release_type" == "RELEASE" ]]; then
    return 0 # true
  fi
  
  # Check for significant patch (patches with PR information)
  local significant_changes=false
  if git tag -l "v${version}" &> /dev/null; then
    # Tag exists, check commit message
    local commit_msg=$(git tag -l --format='%(contents)' "v${version}")
    if [[ -n "$commit_msg" && "$commit_msg" != *"minor fix"* && "$commit_msg" != *"typo"* ]]; then
      # If commit message is substantial, consider it significant
      significant_changes=true
    fi
  fi
  
  # Check last minor version without a patch
  local base_version="${major}.${minor}.0"
  
  # If this patch has significant changes or is explicitly marked
  if $significant_changes; then
    return 0 # true
  fi
  
  # Default to not creating a release for regular patches
  return 1 # false
}

update_version_properties() {
  local new_version="$1"
  local major=$(echo "$new_version" | cut -d. -f1)
  local minor=$(echo "$new_version" | cut -d. -f2)
  local patch=$(echo "$new_version" | cut -d. -f3)
  local current_timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  # Update version properties
  sed -i "s/^version=.*/version=$new_version/" "$VERSION_FILE"
  sed -i "s/^version.major=.*/version.major=$major/" "$VERSION_FILE"
  sed -i "s/^version.minor=.*/version.minor=$minor/" "$VERSION_FILE"
  sed -i "s/^version.patch=.*/version.patch=$patch/" "$VERSION_FILE"
  sed -i "s/^version.full=.*/version.full=$new_version/" "$VERSION_FILE"
  
  # Update release and build information
  sed -i "s/^lastUpdated=.*/lastUpdated=$(date +%Y-%m-%d)/" "$VERSION_FILE"
  sed -i "s/^buildNumber=.*/buildNumber=1/" "$VERSION_FILE"
  sed -i "s/^build.timestamp=.*/build.timestamp=$current_timestamp/" "$VERSION_FILE"
  
  print_success "Updated version in $VERSION_FILE to $new_version"
}

update_pom_versions() {
  local new_version="$1"
  local pom_files=$(find "$RINNA_DIR" -name "pom.xml")
  
  for pom_file in $pom_files; do
    print_header "Processing POM file: $(basename "$pom_file")"
    
    # Check if this is a Rinna project
    if ! grep -q "<groupId>org.rinna</groupId>" "$pom_file"; then
      print_warning "- Not a Rinna project, skipping"
      continue
    fi
    
    # We'll use a simpler approach with sed to avoid AWK syntax issues
    # This approach is more explicit and easier to debug
    
    # 1. Update parent version if it's an org.rinna parent
    if grep -q "<parent>" "$pom_file" && grep -A 5 "<parent>" "$pom_file" | grep -q "<groupId>org.rinna</groupId>"; then
      print_success "- Updating org.rinna parent reference"
      
      # Create a temporary file for processing
      local parent_section=$(grep -A 10 "<parent>" "$pom_file" | grep -B 10 "</parent>" | head -n 20)
      if echo "$parent_section" | grep -q "<groupId>org.rinna</groupId>"; then
        # Use sed to replace the version within the parent section
        sed -i "/<parent>/,/<\/parent>/s|<version>[^<]*</version>|<version>$new_version</version>|g" "$pom_file"
      fi
    fi
    
    # 2. Check for a project-level version outside of parent/dependencies sections
    # This is trickier since we need to avoid dependency versions
    
    # Create a temp file
    cp "$pom_file" "${pom_file}.tmp"
    
    # Extract the content before any <dependencies> or <dependencyManagement> tags
    head_content=$(sed -n '1,/<dependencies>/p' "${pom_file}.tmp" | grep -v "<dependencies>" || echo "")
    if [ -z "$head_content" ]; then
      head_content=$(sed -n '1,/<dependencyManagement>/p' "${pom_file}.tmp" | grep -v "<dependencyManagement>" || echo "")
    fi
    
    # Look for a groupId and version outside of parent
    if echo "$head_content" | grep -v "<parent>" | grep -q "<groupId>org.rinna</groupId>"; then
      # We found an org.rinna groupId outside of parent, look for a version tag nearby
      if echo "$head_content" | grep -v "<parent>" | grep -q "<version>"; then
        print_success "- Updating project version"
        
        # Use a more targeted sed approach to update only the main project version
        # after the groupId and artifactId, but before any dependencies
        sed -i '/<parent>/,/<\/parent>/b; /<dependencies>/,$b; /<groupId>org.rinna<\/groupId>/,/<version>[^<]*<\/version>/ s|<version>[^<]*</version>|<version>'"$new_version"'</version>|' "$pom_file"
      fi
    else
      print_warning "- No Rinna project version found outside parent section"
    fi
    
    # Cleanup
    rm -f "${pom_file}.tmp"
  done
  
  print_success "Updated version in all Rinna POM files to $new_version"
}

update_readme_version() {
  local new_version="$1"
  sed -i -E "s|(\\[\\!\\[Version\\]\\(https://img.shields.io/badge/version-).*(-blue.svg\\)\\])|\\1${new_version}\\2|" "$README_FILE"
  
  # Also update Maven example if it exists
  if grep -q "<artifactId>rinna-core</artifactId>" "$README_FILE"; then
    sed -i -E "s|(<version>)([0-9]+\.[0-9]+\.[0-9]+)(</version>)|\1${new_version}\3|" "$README_FILE"
  fi
  
  print_success "Updated version in $README_FILE to $new_version"
}

update_go_version() {
  local new_version="$1"
  local current_timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
  local go_health_files=(
    "$RINNA_DIR/api/pkg/health/version.go"
    "$RINNA_DIR/api/internal/version/version.go"
  )
  
  # Create version.go files if they don't exist
  mkdir -p "$RINNA_DIR/api/pkg/health"
  if [ ! -f "$RINNA_DIR/api/pkg/health/version.go" ]; then
    cat > "$RINNA_DIR/api/pkg/health/version.go" << EOF
/*
 * Version information for the Rinna API
 *
 * Copyright (c) $(date +%Y) Eric C. Mumford (@heymumford)
 * This file is subject to the terms and conditions defined in
 * the LICENSE file, which is part of this source code package.
 */

package health

// These values are set during the build process
var (
	Version   = "$new_version"
	CommitSHA = "runtime"
	BuildTime = "$current_timestamp"
)
EOF
    print_success "Created version file at $RINNA_DIR/api/pkg/health/version.go"
  else
    # Update existing version.go file
    sed -i -E "s/Version\s*=\s*\"[^\"]*\"/Version   = \"$new_version\"/" "$RINNA_DIR/api/pkg/health/version.go"
    sed -i -E "s/BuildTime\s*=\s*\"[^\"]*\"/BuildTime = \"$current_timestamp\"/" "$RINNA_DIR/api/pkg/health/version.go"
  fi
  
  # Create internal version package if it doesn't exist
  mkdir -p "$RINNA_DIR/api/internal/version"
  if [ ! -f "$RINNA_DIR/api/internal/version/version.go" ]; then
    cat > "$RINNA_DIR/api/internal/version/version.go" << EOF
/*
 * Version information for the Rinna API
 *
 * Copyright (c) $(date +%Y) Eric C. Mumford (@heymumford)
 * This file is subject to the terms and conditions defined in
 * the LICENSE file, which is part of this source code package.
 */

package version

// These values are set during the build process
var (
	Version   = "$new_version"
	CommitSHA = "runtime"
	BuildTime = "$current_timestamp"
)
EOF
    print_success "Created version file at $RINNA_DIR/api/internal/version/version.go"
  else
    # Update existing version.go file
    sed -i -E "s/Version\s*=\s*\"[^\"]*\"/Version   = \"$new_version\"/" "$RINNA_DIR/api/internal/version/version.go"
    sed -i -E "s/BuildTime\s*=\s*\"[^\"]*\"/BuildTime = \"$current_timestamp\"/" "$RINNA_DIR/api/internal/version/version.go"
  fi
  
  print_success "Updated version in Go files to $new_version"
}

update_python_version() {
  local new_version="$1"
  
  # Python doesn't need a version update in the source code since we've modified
  # rinna_config.py to read from version.properties
  
  # We could update a pyproject.toml file if it exists
  if [ -f "$RINNA_DIR/pyproject.toml" ]; then
    sed -i -E "s/version\s*=\s*\"[^\"]*\"/version = \"$new_version\"/" "$RINNA_DIR/pyproject.toml"
    print_success "Updated version in pyproject.toml to $new_version"
  fi
  
  # Create or update virtual environment version file if it exists
  if [ -d "$RINNA_DIR/.venv" ]; then
    echo "$new_version" > "$RINNA_DIR/.venv/version"
    print_success "Updated virtual environment version to $new_version"
  fi
  
  # Force Python config to reload by touching the script
  touch "$RINNA_DIR/bin/rinna_config.py"
  print_success "Updated Python version references to $new_version"
}

verify_consistency() {
  local root_version=$(get_version)
  local inconsistencies=0
  
  print_header "Verifying version consistency across languages..."
  
  # Check if we have the newer version-service and it's usable
  if [ -d "$RINNA_DIR/version-service" ] && command -v go &> /dev/null && [ -f "$RINNA_DIR/version-service/cli/version_cli.go" ]; then
    # Use the Clean Architecture version service for verification
    print_header "Using Clean Architecture version service for verification..."
    
    if [ -f "$RINNA_DIR/version-service/bin/version-cli" ]; then
      # Use the built binary
      if "$RINNA_DIR/version-service/bin/version-cli" --verify; then
        return 0
      else
        return 1
      fi
    else
      # Run with go directly
      if (cd "$RINNA_DIR/version-service" && go run cli/version_cli.go --verify); then
        return 0
      else
        return 1
      fi
    fi
  fi
  
  # Check if we have the enhanced check-versions.sh and it's executable
  if [ -x "$RINNA_DIR/bin/check-versions.sh" ]; then
    print_header "Using enhanced cross-language version checker..."
    if "$RINNA_DIR/bin/check-versions.sh"; then
      return 0
    else
      return 1
    fi
  fi
  
  # Fallback to original verification if neither option is available
  print_header "Fallback: using built-in verification across files..."
  echo -e "Root version (from version.properties): ${GREEN}${root_version}${NC}"
  
  # Check POM files - with improved accuracy to only check relevant versions
  for pom_file in $(find "$RINNA_DIR" -name "pom.xml"); do
    echo -e "Checking ${BLUE}$(basename "$pom_file")${NC}..."
    
    # Check parent version - but only if it's an org.rinna parent
    if grep -q "<parent>" "$pom_file" && grep -q -A 3 "<parent>" "$pom_file" | grep -q "<groupId>org.rinna</groupId>"; then
      local parent_version=$(grep -A 5 "<parent>" "$pom_file" | grep "<version>" | head -1 | sed -E 's/.*<version>(.*)<\/version>.*/\1/')
      if [[ "$parent_version" != "$root_version" ]]; then
        echo -e "  ${RED}org.rinna parent version mismatch: ${parent_version} (should be ${root_version})${NC}"
        ((inconsistencies++))
      else
        echo -e "  ${GREEN}org.rinna parent version: ${parent_version} ✓${NC}"
      fi
    fi
    
    # Check project version, but only for Rinna projects (with org.rinna groupId)
    # and not inside dependency, plugin or other sections
    if grep -q "<groupId>org.rinna</groupId>" "$pom_file"; then
      # Use a more sophisticated approach to extract the main project version
      local project_content=$(cat "$pom_file")
      local project_version=""
      
      # First, remove parent section, dependencies, and plugins sections which might have version tags
      local filtered_content=$(echo "$project_content" | 
        awk '
          BEGIN { print_lines = 1; in_parent = 0; in_dependencies = 0; in_plugins = 0; in_dependencyManagement = 0 }
          /<parent>/ { in_parent = 1; print_lines = 0 }
          /<\/parent>/ { in_parent = 0; print_lines = 0 }
          /<dependencies>/ { in_dependencies = 1; print_lines = 0 }
          /<\/dependencies>/ { in_dependencies = 0; print_lines = 0 }
          /<dependencyManagement>/ { in_dependencyManagement = 1; print_lines = 0 }
          /<\/dependencyManagement>/ { in_dependencyManagement = 0; print_lines = 0 }
          /<plugins>/ { in_plugins = 1; print_lines = 0 }
          /<\/plugins>/ { in_plugins = 0; print_lines = 0 }
          { if (print_lines && !in_parent && !in_dependencies && !in_plugins && !in_dependencyManagement) print }
        ')
      
      # Now look for the project version in this filtered content
      # First make sure we have the org.rinna groupId outside of any special sections
      if echo "$filtered_content" | grep -q "<groupId>org.rinna</groupId>"; then
        project_version=$(echo "$filtered_content" | grep -m 1 "<version>" | sed -E 's/.*<version>(.*)<\/version>.*/\1/')
        
        if [[ -n "$project_version" && "$project_version" != "$root_version" ]]; then
          echo -e "  ${RED}Project version mismatch: ${project_version} (should be ${root_version})${NC}"
          ((inconsistencies++))
        elif [[ -n "$project_version" ]]; then
          echo -e "  ${GREEN}Project version: ${project_version} ✓${NC}"
        fi
      fi
    fi
  done
  
  # Check README.md
  echo -e "Checking ${BLUE}README.md${NC}..."
  local readme_version=$(grep -o "version-.*-blue" "$README_FILE" | cut -d '-' -f 2)
  if [[ "$readme_version" != "$root_version" ]]; then
    echo -e "  ${RED}README version mismatch: ${readme_version} (should be ${root_version})${NC}"
    ((inconsistencies++))
  else
    echo -e "  ${GREEN}README version: ${readme_version} ✓${NC}"
  fi
  
  # Check Go version files
  local go_version_files=(
    "$RINNA_DIR/api/pkg/health/version.go"
    "$RINNA_DIR/api/internal/version/version.go"
  )
  
  for version_file in "${go_version_files[@]}"; do
    if [ -f "$version_file" ]; then
      echo -e "Checking ${BLUE}$(basename "$version_file")${NC}..."
      local go_version=$(grep -o 'Version\s*=\s*"[^"]*"' "$version_file" | sed -E 's/.*"([^"]*)".*$/\1/')
      if [[ -z "$go_version" ]]; then
        # Try again with different formatting
        go_version=$(grep -o 'Version.*"[^"]*"' "$version_file" | sed -E 's/.*"([^"]*)".*$/\1/')
      fi
      
      if [[ "$go_version" != "$root_version" ]]; then
        echo -e "  ${RED}Go version mismatch: ${go_version} (should be ${root_version})${NC}"
        ((inconsistencies++))
      else
        echo -e "  ${GREEN}Go version: ${go_version} ✓${NC}"
      fi
    fi
  done
  
  # Check Python configuration - test rinna_config.py
  if [ -f "$RINNA_DIR/bin/rinna_config.py" ]; then
    echo -e "Checking ${BLUE}Python config${NC}..."
    
    # Run the Python script with just the version info request
    # Redirect stderr to /dev/null to suppress warnings about config file
    local python_version=$("$RINNA_DIR/bin/rinna_config.py" project.version 2>/dev/null)
    
    if [[ -z "$python_version" ]]; then
      # Try running the script directly and parse the output
      python_version=$(python3 "$RINNA_DIR/bin/rinna_config.py" 2>/dev/null | grep -o "v[0-9.]*" | sed 's/^v//')
    fi
    
    # Check if the version is still empty or contains error messages
    if [[ -z "$python_version" || "$python_version" == *"Warning"* || "$python_version" == *"Error"* ]]; then
      # Directly try to verify the Python module's _read_version_from_properties logic
      echo -e "  ${YELLOW}Testing direct access to version.properties...${NC}"
      
      # Create a simple test script to directly read version.properties
      local test_script=$(mktemp)
      cat > "$test_script" << 'EOF'
#!/usr/bin/env python3
import os, sys
script_dir = os.path.dirname(sys.argv[1])
project_root = os.path.abspath(os.path.join(script_dir, ".."))
version_file = os.path.join(project_root, "version.properties")
with open(version_file, 'r') as f:
    for line in f:
        line = line.strip()
        if line.startswith("version="):
            print(line.split("=", 1)[1].strip())
            break
EOF
      chmod +x "$test_script"
      
      # Run the test script
      python_version=$(python3 "$test_script" "$RINNA_DIR/bin/rinna_config.py" 2>/dev/null)
      rm "$test_script"
      
      if [[ -z "$python_version" ]]; then
        echo -e "  ${YELLOW}Could not determine Python version (but will be read from version.properties)${NC}"
      elif [[ "$python_version" != "$root_version" ]]; then
        echo -e "  ${RED}Python version mismatch: ${python_version} (should be ${root_version})${NC}"
        ((inconsistencies++))
      else
        echo -e "  ${GREEN}Python version: ${python_version} ✓${NC}"
        echo -e "  ${BLUE}Note: Python will read this from version.properties at runtime${NC}"
      fi
    elif [[ "$python_version" != "$root_version" ]]; then
      echo -e "  ${RED}Python version mismatch: ${python_version} (should be ${root_version})${NC}"
      ((inconsistencies++))
    else
      echo -e "  ${GREEN}Python version: ${python_version} ✓${NC}"
    fi
  fi
  
  # Check pyproject.toml if it exists
  if [ -f "$RINNA_DIR/pyproject.toml" ]; then
    echo -e "Checking ${BLUE}pyproject.toml${NC}..."
    local pyproject_version=$(grep -o 'version\s*=\s*"[^"]*"' "$RINNA_DIR/pyproject.toml" | sed -E 's/.*"([^"]*)".*$/\1/')
    
    if [[ -z "$pyproject_version" ]]; then
      echo -e "  ${YELLOW}Could not determine version in pyproject.toml${NC}"
    elif [[ "$pyproject_version" != "$root_version" ]]; then
      echo -e "  ${RED}pyproject.toml version mismatch: ${pyproject_version} (should be ${root_version})${NC}"
      ((inconsistencies++))
    else
      echo -e "  ${GREEN}pyproject.toml version: ${pyproject_version} ✓${NC}"
    fi
  fi
  
  # Check virtual environment version file if it exists
  if [ -f "$RINNA_DIR/.venv/version" ]; then
    echo -e "Checking ${BLUE}Python virtual environment${NC}..."
    local venv_version=$(cat "$RINNA_DIR/.venv/version" 2>/dev/null)
    
    if [[ -z "$venv_version" ]]; then
      echo -e "  ${YELLOW}Could not determine virtual environment version${NC}"
    elif [[ "$venv_version" != "$root_version" ]]; then
      echo -e "  ${RED}Virtual environment version mismatch: ${venv_version} (should be ${root_version})${NC}"
      ((inconsistencies++))
    else
      echo -e "  ${GREEN}Virtual environment version: ${venv_version} ✓${NC}"
    fi
  fi
  
  # Report result
  if [[ $inconsistencies -eq 0 ]]; then
    print_success "All versions are consistent!"
    return 0
  else
    echo -e "${RED}Found ${inconsistencies} version inconsistencies!${NC}"
    return 1
  fi
}

create_git_tag() {
  local version="$1" message="$2"
  local tag_name="v${version}"
  
  if [[ -z "$message" ]]; then
    message="Release version ${version}"
  fi
  
  git tag -a "$tag_name" -m "$message"
  print_success "Created git tag: ${tag_name}"
}

# Command Functions
cmd_current() {
  local current_version=$(get_version)
  IFS='.' read -r major minor patch <<< "$current_version"
  
  # Get other properties
  local last_updated=$(get_property "lastUpdated")
  local release_type=$(get_property "releaseType")
  local build_number=$(get_property "buildNumber")
  
  print_header "Current version information:"
  echo -e "  Version: ${GREEN}${current_version}${NC}"
  echo -e "  Major: ${major}, Minor: ${minor}, Patch: ${patch}"
  echo -e "  Last Updated: ${last_updated}"
  echo -e "  Release Type: ${release_type}"
  echo -e "  Build Number: ${build_number}"
  
  # Check git tag
  if git tag -l "v${current_version}" | grep -q "v${current_version}"; then
    echo -e "  Git tag: ${GREEN}v${current_version}${NC} exists"
  else
    echo -e "  Git tag: ${YELLOW}v${current_version}${NC} does not exist"
  fi
  
  # Check GitHub release
  if command -v gh &> /dev/null && gh release view "v${current_version}" &> /dev/null; then
    echo -e "  GitHub release: ${GREEN}v${current_version}${NC} exists"
  else
    echo -e "  GitHub release: ${YELLOW}v${current_version}${NC} does not exist"
  fi
  
  # Show release eligibility
  if should_create_github_release "$current_version" "$release_type"; then
    echo -e "  GitHub release: ${BLUE}Eligible for GitHub release${NC}"
  else
    echo -e "  GitHub release: ${YELLOW}Not eligible for GitHub release${NC} (minor patch or SNAPSHOT)"
  fi
  
  verify_consistency
}

cmd_verify() {
  verify_consistency
}

cmd_update() {
  local current_version=$(get_version)
  
  print_header "Updating all files to match version.properties (${current_version})"
  
  # Check if we have a version-service directory - if so, use it
  if [ -d "$RINNA_DIR/version-service" ]; then
    # Try running the version-service CLI to update files
    if command -v go &> /dev/null && [ -f "$RINNA_DIR/version-service/cli/version_cli.go" ]; then
      print_header "Using Clean Architecture version service..."
      # Check if the CLI is already built
      if [ -f "$RINNA_DIR/version-service/bin/version-cli" ]; then
        "$RINNA_DIR/version-service/bin/version-cli" --update
      else
        # Fallback to running with go directly
        (cd "$RINNA_DIR/version-service" && go run cli/version_cli.go --update)
      fi
      print_success "Version service updated all files"
    else
      # Fallback to enhanced update-versions.sh
      print_header "Using enhanced update script..."
      "$RINNA_DIR/bin/update-versions.sh"
    fi
  else
    # Use legacy update methods
    print_header "Using legacy update methods..."
    update_pom_versions "$current_version"
    update_readme_version "$current_version"
    update_go_version "$current_version"
    update_python_version "$current_version"
  fi
  
  # Add all version-related files to git
  git add "$RINNA_DIR/version.properties" "$RINNA_DIR/pom.xml" $(find "$RINNA_DIR" -name "pom.xml" | grep -v "$RINNA_DIR/pom.xml") "$README_FILE" 
  
  # Add Go files
  find "$RINNA_DIR/api" -name "version.go" -type f | xargs git add 2>/dev/null || true
  
  # Add Python-related files if they exist
  if [ -f "$RINNA_DIR/pyproject.toml" ]; then
    git add "$RINNA_DIR/pyproject.toml"
  fi
  if [ -f "$RINNA_DIR/.venv/version" ]; then
    git add "$RINNA_DIR/.venv/version"
  fi
  if [ -f "$RINNA_DIR/bin/rinna_config.py" ]; then
    # Touch to update timestamp to force reload
    touch "$RINNA_DIR/bin/rinna_config.py"
    git add "$RINNA_DIR/bin/rinna_config.py"
  fi
  
  # Commit the changes
  git commit -m "Sync version files with version.properties (${current_version})"
  print_success "Committed version changes"
  
  # Run verification
  print_header "Verifying version consistency..."
  if [ -d "$RINNA_DIR/version-service" ] && command -v go &> /dev/null && [ -f "$RINNA_DIR/version-service/cli/version_cli.go" ]; then
    # Use the version-service verification
    if [ -f "$RINNA_DIR/version-service/bin/version-cli" ]; then
      "$RINNA_DIR/version-service/bin/version-cli" --verify
    else
      # Fallback to running with go directly
      (cd "$RINNA_DIR/version-service" && go run cli/version_cli.go --verify)
    fi
  else
    # Use the enhanced check-versions.sh
    "$RINNA_DIR/bin/check-versions.sh"
  fi
}

cmd_bump_version() {
  local index="$1" message="$2"
  local current_version=$(get_version)
  local new_version=$(increment_version "$current_version" "$index")
  
  print_header "Bumping version: ${current_version} → ${GREEN}${new_version}${NC}"
  print_header "This will only update Rinna project versions, not dependency versions"
  
  # Create a detailed log of what we're about to update
  local log_file="/tmp/rinna-version-update-$$.log"
  echo "Rinna Version Update Log - $(date)" > "$log_file"
  echo "Current version: $current_version" >> "$log_file"
  echo "New version: $new_version" >> "$log_file"
  echo "Affected files:" >> "$log_file"
  echo "- $VERSION_FILE (properties file)" >> "$log_file"
  echo "- $README_FILE (README badge)" >> "$log_file"
  
  # List POM files that will be checked
  echo "POM files to be checked:" >> "$log_file"
  for pom_file in $(find "$RINNA_DIR" -name "pom.xml"); do
    # Check if this POM has org.rinna groupId
    if grep -q "<groupId>org.rinna</groupId>" "$pom_file"; then
      echo "- $pom_file (Rinna project, will update version)" >> "$log_file"
    else
      echo "- $pom_file (Not a Rinna project, will NOT update version)" >> "$log_file"
    fi
  done
  
  # List Go files that will be updated
  echo "Go version files to be updated:" >> "$log_file"
  for go_file in "$RINNA_DIR/api/pkg/health/version.go" "$RINNA_DIR/api/internal/version/version.go"; do
    if [ -f "$go_file" ]; then
      echo "- $go_file" >> "$log_file"
    else
      echo "- $go_file (will be created)" >> "$log_file"
    fi
  done
  
  # List Python files that will be updated
  echo "Python files to be updated:" >> "$log_file"
  echo "- $RINNA_DIR/bin/rinna_config.py (reads from version.properties)" >> "$log_file"
  if [ -f "$RINNA_DIR/pyproject.toml" ]; then
    echo "- $RINNA_DIR/pyproject.toml" >> "$log_file"
  fi
  if [ -d "$RINNA_DIR/.venv" ]; then
    echo "- $RINNA_DIR/.venv/version" >> "$log_file"
  fi
  
  echo "Starting updates at $(date)" >> "$log_file"
  
  # Perform the actual updates
  update_version_properties "$new_version"
  update_pom_versions "$new_version"
  update_readme_version "$new_version"
  update_go_version "$new_version"
  update_python_version "$new_version"
  
  echo "Updates completed at $(date)" >> "$log_file"
  
  # Generate architecture diagrams for major or minor version bumps
  if [[ "$index" -eq 0 || "$index" -eq 1 ]]; then
    if [[ -x "$RINNA_DIR/bin/rin-diagrams" ]]; then
      print_header "Generating updated architecture diagrams for ${new_version}..."
      "$RINNA_DIR/bin/rin-diagrams" --force || print_warning "Failed to generate architecture diagrams"
      
      # Add new diagrams to git if they were created
      if [[ -d "$RINNA_DIR/docs/architecture/diagrams" ]]; then
        git add "$RINNA_DIR/docs/architecture"
      fi
    else
      print_warning "rin-diagrams not found or not executable, skipping architecture diagram generation"
    fi
  fi
  
  # Add all affected files to git
  print_header "Adding version files to git..."
  git add "$VERSION_FILE" "$RINNA_DIR/pom.xml" $(find "$RINNA_DIR" -name "pom.xml" | grep -v "$RINNA_DIR/pom.xml") "$README_FILE" "$RINNA_DIR/api/pkg/health/version.go" "$RINNA_DIR/api/internal/version/version.go"
  
  # Add Python-related files if they exist
  if [ -f "$RINNA_DIR/pyproject.toml" ]; then
    git add "$RINNA_DIR/pyproject.toml"
  fi
  if [ -f "$RINNA_DIR/.venv/version" ]; then
    git add "$RINNA_DIR/.venv/version"
  fi
  # Touch to update timestamp to force reload 
  touch "$RINNA_DIR/bin/rinna_config.py"
  git add "$RINNA_DIR/bin/rinna_config.py"
  
  # Log the update details
  echo "Log available at: $log_file"
  print_success "Created detailed version update log at $log_file"
  
  # Commit changes
  git commit -m "Bump version to ${new_version}"
  print_success "Committed version change"
  
  if [[ -n "$message" ]]; then
    create_git_tag "$new_version" "$message"
  fi
  
  # Verify consistency and append results to log
  echo "Verification results:" >> "$log_file"
  verify_consistency | tee -a "$log_file"
  
  print_success "Version bump complete: ${current_version} → ${new_version}"
  print_success "Note: Only Rinna project versions were updated, not dependency versions"
  
  return 0
}

cmd_set() {
  local new_version="$1" message="$2"
  
  if [[ ! "$new_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    print_error "Invalid version format. Must be in format: X.Y.Z"
  fi
  
  local current_version=$(get_version)
  print_header "Setting version: ${current_version} → ${GREEN}${new_version}${NC}"
  print_header "This will only update Rinna project versions, not dependency versions"
  
  # Create a detailed log of what we're about to update
  local log_file="/tmp/rinna-version-update-$$.log"
  echo "Rinna Version Update Log - $(date)" > "$log_file"
  echo "Current version: $current_version" >> "$log_file"
  echo "New version: $new_version" >> "$log_file"
  echo "Affected files:" >> "$log_file"
  echo "- $VERSION_FILE (properties file)" >> "$log_file"
  echo "- $README_FILE (README badge)" >> "$log_file"
  
  # List POM files that will be checked
  echo "POM files to be checked:" >> "$log_file"
  for pom_file in $(find "$RINNA_DIR" -name "pom.xml"); do
    # Check if this POM has org.rinna groupId
    if grep -q "<groupId>org.rinna</groupId>" "$pom_file"; then
      echo "- $pom_file (Rinna project, will update version)" >> "$log_file"
    else
      echo "- $pom_file (Not a Rinna project, will NOT update version)" >> "$log_file"
    fi
  done
  
  # List Go files that will be updated
  echo "Go version files to be updated:" >> "$log_file"
  for go_file in "$RINNA_DIR/api/pkg/health/version.go" "$RINNA_DIR/api/internal/version/version.go"; do
    if [ -f "$go_file" ]; then
      echo "- $go_file" >> "$log_file"
    else
      echo "- $go_file (will be created)" >> "$log_file"
    fi
  done
  
  # List Python files that will be updated
  echo "Python files to be updated:" >> "$log_file"
  echo "- $RINNA_DIR/bin/rinna_config.py (reads from version.properties)" >> "$log_file"
  if [ -f "$RINNA_DIR/pyproject.toml" ]; then
    echo "- $RINNA_DIR/pyproject.toml" >> "$log_file"
  fi
  if [ -d "$RINNA_DIR/.venv" ]; then
    echo "- $RINNA_DIR/.venv/version" >> "$log_file"
  fi
  
  echo "Starting updates at $(date)" >> "$log_file"
  
  # Perform the actual updates
  update_version_properties "$new_version"
  update_pom_versions "$new_version"
  update_readme_version "$new_version"
  update_go_version "$new_version"
  update_python_version "$new_version"
  
  echo "Updates completed at $(date)" >> "$log_file"
  
  # Generate architecture diagrams for major version changes or when changing to x.0.0 versions
  if [[ "${new_version%.*}" != "${current_version%.*}" ]] || [[ "${new_version}" =~ ^[0-9]+\.0\.0$ ]]; then
    if [[ -x "$RINNA_DIR/bin/rin-diagrams" ]]; then
      print_header "Generating updated architecture diagrams for ${new_version}..."
      "$RINNA_DIR/bin/rin-diagrams" --force || print_warning "Failed to generate architecture diagrams"
      
      # Add new diagrams to git if they were created
      if [[ -d "$RINNA_DIR/docs/architecture/diagrams" ]]; then
        git add "$RINNA_DIR/docs/architecture"
      fi
    else
      print_warning "rin-diagrams not found or not executable, skipping architecture diagram generation"
    fi
  fi
  
  # Add all affected files to git
  print_header "Adding version files to git..."
  git add "$VERSION_FILE" "$RINNA_DIR/pom.xml" $(find "$RINNA_DIR" -name "pom.xml" | grep -v "$RINNA_DIR/pom.xml") "$README_FILE" "$RINNA_DIR/api/pkg/health/version.go" "$RINNA_DIR/api/internal/version/version.go"
  
  # Add Python-related files if they exist
  if [ -f "$RINNA_DIR/pyproject.toml" ]; then
    git add "$RINNA_DIR/pyproject.toml"
  fi
  if [ -f "$RINNA_DIR/.venv/version" ]; then
    git add "$RINNA_DIR/.venv/version"
  fi
  # Touch to update timestamp to force reload 
  touch "$RINNA_DIR/bin/rinna_config.py"
  git add "$RINNA_DIR/bin/rinna_config.py"
  
  # Log the update details
  echo "Log available at: $log_file"
  print_success "Created detailed version update log at $log_file"
  
  # Commit changes
  git commit -m "Set version to ${new_version}"
  print_success "Committed version change"
  
  if [[ -n "$message" ]]; then
    create_git_tag "$new_version" "$message"
  fi
  
  # Verify consistency and append results to log
  echo "Verification results:" >> "$log_file"
  verify_consistency | tee -a "$log_file"
  
  print_success "Version update complete: ${current_version} → ${new_version}"
  print_success "Note: Only Rinna project versions were updated, not dependency versions"
}

cmd_release() {
  local current_version=$(get_version) message="$1" force_github="$2"
  
  verify_consistency || print_error "Cannot create release due to version inconsistencies"
  
  if [[ -z "$message" ]]; then
    message="Release version ${current_version}"
  fi
  
  print_header "Creating release for version: ${GREEN}${current_version}${NC}"
  
  # Check if there are uncommitted changes
  if ! git diff --quiet || ! git diff --cached --quiet; then
    print_warning "Uncommitted changes detected in repository"
    # Ask user what to do
    echo -e "Select an action:"
    echo -e "  1) Stash changes temporarily (recommended)"
    echo -e "  2) Continue without committing release type change"
    echo -e "  3) Abort release process"
    read -p "Enter option (1-3): " choice
    
    case "$choice" in
      1)
        # Stash changes
        print_header "Stashing changes temporarily"
        git stash push -m "Stashed changes before release ${current_version}"
        
        # Update release type if needed
        local current_release_type=$(get_property "releaseType")
        if [[ "$current_release_type" != "RELEASE" ]]; then
          sed -i "s/^releaseType=.*/releaseType=RELEASE/" "$VERSION_FILE"
          git add "$VERSION_FILE"
          if ! git commit -m "Update release type for version ${current_version}"; then
            git stash pop
            print_error "Failed to commit release type change"
          fi
          print_success "Updated release type to RELEASE"
        else
          print_warning "Release type is already set to RELEASE, skipping update"
        fi
        
        # Flag to pop stash at the end
        local pop_stash=true
        ;;
      2)
        # Skip commit
        print_warning "Skipping release type commit"
        local current_release_type=$(get_property "releaseType")
        if [[ "$current_release_type" != "RELEASE" ]]; then
          sed -i "s/^releaseType=.*/releaseType=RELEASE/" "$VERSION_FILE"
          print_success "Updated release type to RELEASE (not committed)"
        else
          print_warning "Release type is already set to RELEASE, no change needed"
        fi
        local skip_commit=true
        ;;
      3)
        # Abort
        print_error "Release process aborted by user"
        ;;
      *)
        print_error "Invalid option"
        ;;
    esac
  else
    # Normal process when there are no uncommitted changes
    local current_release_type=$(get_property "releaseType")
    if [[ "$current_release_type" != "RELEASE" ]]; then
      sed -i "s/^releaseType=.*/releaseType=RELEASE/" "$VERSION_FILE"
      git add "$VERSION_FILE"
      git commit -m "Update release type for version ${current_version}"
      print_success "Updated release type to RELEASE"
    else
      print_warning "Release type is already set to RELEASE, skipping update"
    fi
  fi
  
  # Create git tag if it doesn't exist
  if ! git tag -l "v${current_version}" | grep -q "v${current_version}"; then
    create_git_tag "$current_version" "$message"
  else
    echo -e "${YELLOW}Git tag v${current_version} already exists${NC}"
  fi
  
  # Determine if this version should have a GitHub release
  local create_gh_release="$force_github"
  if [[ "$create_gh_release" != "true" ]]; then
    if should_create_github_release "$current_version" "RELEASE"; then
      create_gh_release="true"
      print_header "Version ${current_version} qualifies for a GitHub release"
    else
      print_warning "Version ${current_version} does not qualify for automatic GitHub release"
      
      # Ask if user wants to create one anyway
      read -p "Create GitHub release anyway? [y/N] " -r
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        create_gh_release="true"
      fi
    fi
  fi
  
  # Create GitHub release if appropriate
  if [[ "$create_gh_release" == "true" ]] && command -v gh &> /dev/null; then
    # Collect release notes
    local notes=""
    if [[ -f "CHANGELOG.md" ]]; then
      # Try to extract this version's notes from CHANGELOG
      local changelog_section=$(sed -n "/## \[${current_version}\]/,/## \[/p" CHANGELOG.md | sed '$d')
      if [[ -n "$changelog_section" ]]; then
        notes="$changelog_section"
      fi
    fi
    
    # If no notes from changelog, generate from commits
    if [[ -z "$notes" ]]; then
      # Find the previous tag to compare against
      local prev_tag=$(git describe --abbrev=0 --tags "v${current_version}^" 2>/dev/null || echo "")
      if [[ -n "$prev_tag" ]]; then
        notes="## Changes since ${prev_tag}\n\n$(git log --pretty=format:"* %s" ${prev_tag}..v${current_version})"
      else
        notes="$message"
      fi
    fi
    
    # Create the GitHub release
    if echo -e "$notes" | gh release create "v${current_version}" -t "Rinna ${current_version}" -F -; then
      print_success "Created GitHub release: v${current_version}"
    else
      print_error "Failed to create GitHub release"
    fi
  elif [[ "$create_gh_release" == "true" ]]; then
    print_warning "GitHub CLI not installed. Cannot create GitHub release."
  fi
  
  # Restore stashed changes if needed
  if [[ "$pop_stash" == "true" ]]; then
    print_header "Restoring stashed changes"
    if ! git stash pop; then
      print_warning "There might be conflicts from stash pop. Please resolve them manually."
    fi
  fi
  
  # If we skipped the commit, remind user
  if [[ "$skip_commit" == "true" ]]; then
    print_warning "Remember: Release type in $VERSION_FILE was changed but not committed"
    print_warning "You may want to commit this change manually later"
  fi
}

cmd_tag() {
  local current_version=$(get_version) message="$1"
  
  verify_consistency || print_error "Cannot create tag due to version inconsistencies"
  
  if [[ -z "$message" ]]; then
    message="Version ${current_version}"
  fi
  
  print_header "Creating git tag for version: ${GREEN}${current_version}${NC}"
  create_git_tag "$current_version" "$message"
}

# Display help
show_help() {
  cat << EOF
${BLUE}rin-version${NC} - Rinna version management utility

Usage: rin-version [command] [options]

Commands:
  current                 Show current version information
  major                   Bump major version (x.0.0)
  minor                   Bump minor version (0.x.0)
  patch                   Bump patch version (0.0.x)
  set <version>           Set to specific version (e.g., 1.2.3)
  release                 Create a release from current version
  tag                     Create a git tag for current version
  verify                  Verify version consistency across files
  update                  Update all files to match version.properties

Options:
  -m, --message <msg>     Custom release/commit message
  -g, --github            Force GitHub release creation (regardless of version type)
  -h, --help              Show this help message

Release Behavior:
  - Git tags are created for ALL version changes
  - GitHub releases are automatically created for:
    • Major versions (x.0.0)
    • Minor versions (0.x.0) 
    • Significant patch versions (based on commit message)
    • Versions explicitly marked as RELEASE type
  - For other patch versions, you'll be prompted to create a GitHub release
  - Use --github to force GitHub release creation for any version
  - If uncommitted changes exist when creating a release, you'll be prompted to:
    • Stash changes temporarily (recommended)
    • Continue without committing release type change
    • Abort the release process

Version Updates:
  - Only Rinna project versions are updated in POM files (org.rinna groupId)
  - Dependency versions are NEVER updated to avoid unintended version changes
  - Python components read from the central version.properties file
  - Go components have version info updated in their respective files
  - Virtual environment version is updated if present
  - A detailed log file is created at /tmp/rinna-version-update-[PID].log
  - The verify command checks for version inconsistencies across the project

Examples:
  rin-version current     # Show current version information
  rin-version patch       # Bump patch version
  rin-version set 2.0.0   # Set version to 2.0.0
  rin-version release -g  # Force GitHub release creation
EOF
}

# Parse arguments
COMMAND=""
VERSION=""
MESSAGE=""
FORCE_GITHUB="false"

while [[ $# -gt 0 ]]; do
  case $1 in
    current|major|minor|patch|release|tag|verify|update)
      COMMAND="$1"
      shift
      ;;
    set)
      COMMAND="set"
      if [[ $# -gt 1 && ! "$2" =~ ^- ]]; then
        VERSION="$2"
        shift
      else
        print_error "Version must be provided after 'set' command"
      fi
      shift
      ;;
    -m|--message)
      if [[ $# -gt 1 && ! "$2" =~ ^- ]]; then
        MESSAGE="$2"
        shift
      else
        print_error "Message must be provided after -m/--message"
      fi
      shift
      ;;
    -g|--github)
      FORCE_GITHUB="true"
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      print_error "Unknown option or command: $1"
      ;;
  esac
done

# Ensure version.properties exists
if [[ ! -f "$VERSION_FILE" ]]; then
  current_version=$(grep -m 1 "<version>" "$RINNA_DIR/pom.xml" | sed -E 's/.*<version>(.*)<\/version>.*/\1/')
  print_warning "version.properties not found, creating with version $current_version"
  cat > "$VERSION_FILE" << EOF
version=$current_version
lastUpdated=$(date +%Y-%m-%d)
releaseType=SNAPSHOT
buildNumber=1
EOF
fi

# Process command
case "$COMMAND" in
  current)
    cmd_current
    ;;
  verify)
    cmd_verify
    ;;
  update)
    cmd_update
    ;;
  major)
    cmd_bump_version 0 "$MESSAGE"
    ;;
  minor)
    cmd_bump_version 1 "$MESSAGE"
    ;;
  patch)
    cmd_bump_version 2 "$MESSAGE"
    ;;
  set)
    cmd_set "$VERSION" "$MESSAGE"
    ;;
  release)
    cmd_release "$MESSAGE" "$FORCE_GITHUB"
    ;;
  tag)
    cmd_tag "$MESSAGE"
    ;;
  *)
    print_error "No command specified"
    ;;
esac