#!/usr/bin/env bash

#
# rin-version - Streamlined Rinna version management utility
#
# Copyright (c) 2025 Eric C. Mumford (@heymumford)
# This file is subject to the terms and conditions defined in
# the LICENSE file, which is part of this source code package.
# (MIT License)
#

set -e

# Constants
RINNA_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
VERSION_FILE="$RINNA_DIR/version.properties"
README_FILE="$RINNA_DIR/README.md"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# UI Functions
print_header() { echo -e "${BLUE}$1${NC}"; }
print_success() { echo -e "${GREEN}$1${NC}"; }
print_warning() { echo -e "${YELLOW}$1${NC}"; }
print_error() { echo -e "${RED}$1${NC}"; exit 1; }

# Helper Functions
get_version() {
  grep -m 1 "^version=" "$VERSION_FILE" | cut -d'=' -f2
}

get_property() {
  local prop="$1"
  grep -m 1 "^$prop=" "$VERSION_FILE" | cut -d'=' -f2
}

increment_version() {
  local version="$1" index="$2"
  IFS='.' read -r -a parts <<< "$version"
  
  # Increment the specified part
  parts[$index]=$((parts[$index] + 1))
  
  # Reset lower parts to 0
  for ((i=index+1; i<${#parts[@]}; i++)); do
    parts[$i]=0
  done
  
  echo "${parts[0]}.${parts[1]}.${parts[2]}"
}

# Determine if a version should have a GitHub release
# Based on: major/minor versions always get releases,
# patch versions only get releases for significant changes or if marked as RELEASE
should_create_github_release() {
  local version="$1" release_type="$2"
  IFS='.' read -r major minor patch <<< "$version"
  
  # Always create releases for major and minor versions
  if [[ "$patch" == "0" ]]; then
    return 0 # true
  fi
  
  # Create releases for explicitly marked RELEASE versions
  if [[ "$release_type" == "RELEASE" ]]; then
    return 0 # true
  fi
  
  # Check for significant patch (patches with PR information)
  local significant_changes=false
  if git tag -l "v${version}" &> /dev/null; then
    # Tag exists, check commit message
    local commit_msg=$(git tag -l --format='%(contents)' "v${version}")
    if [[ -n "$commit_msg" && "$commit_msg" != *"minor fix"* && "$commit_msg" != *"typo"* ]]; then
      # If commit message is substantial, consider it significant
      significant_changes=true
    fi
  fi
  
  # Check last minor version without a patch
  local base_version="${major}.${minor}.0"
  
  # If this patch has significant changes or is explicitly marked
  if $significant_changes; then
    return 0 # true
  fi
  
  # Default to not creating a release for regular patches
  return 1 # false
}

update_version_properties() {
  local new_version="$1"
  sed -i "s/^version=.*/version=$new_version/" "$VERSION_FILE"
  sed -i "s/^lastUpdated=.*/lastUpdated=$(date +%Y-%m-%d)/" "$VERSION_FILE"
  sed -i "s/^buildNumber=.*/buildNumber=1/" "$VERSION_FILE"
  print_success "Updated version in $VERSION_FILE to $new_version"
}

update_pom_versions() {
  local new_version="$1"
  local pom_files=$(find "$RINNA_DIR" -name "pom.xml")
  
  for pom_file in $pom_files; do
    # Update parent version if it exists
    if grep -q "<parent>" "$pom_file"; then
      awk -v new_version="$new_version" '
      BEGIN { in_parent = 0 }
      /<parent>/ { in_parent = 1; print; next }
      /<\/parent>/ { in_parent = 0; print; next }
      /<version>/ && in_parent { gsub(/>.*</, ">" new_version "<") }
      { print }
      ' "$pom_file" > "${pom_file}.tmp"
      
      mv "${pom_file}.tmp" "$pom_file"
    fi
    
    # Update project version outside of parent
    if grep -q "<version>" "$pom_file"; then
      awk -v version="$new_version" '
      BEGIN { in_parent = 0; done = 0 }
      /<parent>/ { in_parent = 1 }
      /<\/parent>/ { in_parent = 0 }
      /<version>/ && !in_parent && !done {
        sub(/>.*</, ">" version "<"); done = 1
      }
      { print }
      ' "$pom_file" > "${pom_file}.tmp"
      
      mv "${pom_file}.tmp" "$pom_file"
    fi
  done
  
  print_success "Updated version in all POM files to $new_version"
}

update_readme_version() {
  local new_version="$1"
  sed -i -E "s|(\\[\\!\\[Version\\]\\(https://img.shields.io/badge/version-).*(-blue.svg\\)\\])|\\1${new_version}\\2|" "$README_FILE"
  
  # Also update Maven example if it exists
  if grep -q "<artifactId>rinna-core</artifactId>" "$README_FILE"; then
    sed -i -E "s|(<version>)([0-9]+\.[0-9]+\.[0-9]+)(</version>)|\1${new_version}\3|" "$README_FILE"
  fi
  
  print_success "Updated version in $README_FILE to $new_version"
}

update_go_version() {
  local new_version="$1"
  local go_health_files=(
    "$RINNA_DIR/api/pkg/health/version.go"
    "$RINNA_DIR/api/internal/version/version.go"
  )
  
  # Create version.go files if they don't exist
  mkdir -p "$RINNA_DIR/api/pkg/health"
  if [ ! -f "$RINNA_DIR/api/pkg/health/version.go" ]; then
    cat > "$RINNA_DIR/api/pkg/health/version.go" << EOF
/*
 * Version information for the Rinna API
 *
 * Copyright (c) $(date +%Y) Eric C. Mumford (@heymumford)
 * This file is subject to the terms and conditions defined in
 * the LICENSE file, which is part of this source code package.
 */

package health

// These values are set during the build process
var (
	Version = "$new_version"
	CommitSHA = "runtime"
	BuildTime = "$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
)
EOF
    print_success "Created version file at $RINNA_DIR/api/pkg/health/version.go"
  else
    # Update existing version.go file
    sed -i -E "s/Version = \"[^\"]*\"/Version = \"$new_version\"/" "$RINNA_DIR/api/pkg/health/version.go"
    sed -i -E "s/BuildTime = \"[^\"]*\"/BuildTime = \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"/" "$RINNA_DIR/api/pkg/health/version.go"
  fi
  
  # Create internal version package if it doesn't exist
  mkdir -p "$RINNA_DIR/api/internal/version"
  if [ ! -f "$RINNA_DIR/api/internal/version/version.go" ]; then
    cat > "$RINNA_DIR/api/internal/version/version.go" << EOF
/*
 * Version information for the Rinna API
 *
 * Copyright (c) $(date +%Y) Eric C. Mumford (@heymumford)
 * This file is subject to the terms and conditions defined in
 * the LICENSE file, which is part of this source code package.
 */

package version

// These values are set during the build process
var (
	Version = "$new_version"
	CommitSHA = "runtime"
	BuildTime = "$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
)
EOF
    print_success "Created version file at $RINNA_DIR/api/internal/version/version.go"
  else
    # Update existing version.go file
    sed -i -E "s/Version = \"[^\"]*\"/Version = \"$new_version\"/" "$RINNA_DIR/api/internal/version/version.go"
    sed -i -E "s/BuildTime = \"[^\"]*\"/BuildTime = \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"/" "$RINNA_DIR/api/internal/version/version.go"
  fi
  
  print_success "Updated version in Go files to $new_version"
}

verify_consistency() {
  local root_version=$(get_version)
  local inconsistencies=0
  
  print_header "Verifying version consistency across files..."
  echo -e "Root version (from version.properties): ${GREEN}${root_version}${NC}"
  
  # Check POM files
  for pom_file in $(find "$RINNA_DIR" -name "pom.xml"); do
    # Check project version
    if grep -q "<version>" "$pom_file" && ! grep -q "<parent>" "$pom_file"; then
      local project_version=$(grep -m 1 "<version>" "$pom_file" | sed -E 's/.*<version>(.*)<\/version>.*/\1/')
      if [[ "$project_version" != "$root_version" ]]; then
        echo -e "${RED}Project version mismatch in ${pom_file}: ${project_version} (should be ${root_version})${NC}"
        ((inconsistencies++))
      fi
    fi
    
    # Check parent version
    if grep -q "<parent>" "$pom_file"; then
      local parent_version=$(grep -A 3 "<parent>" "$pom_file" | grep "<version>" | sed -E 's/.*<version>(.*)<\/version>.*/\1/')
      if [[ "$parent_version" != "$root_version" ]]; then
        echo -e "${RED}Parent version mismatch in ${pom_file}: ${parent_version} (should be ${root_version})${NC}"
        ((inconsistencies++))
      fi
    fi
  done
  
  # Check README.md
  local readme_version=$(grep -o "version-.*-blue" "$README_FILE" | cut -d '-' -f 2)
  if [[ "$readme_version" != "$root_version" ]]; then
    echo -e "${RED}README version mismatch: ${readme_version} (should be ${root_version})${NC}"
    ((inconsistencies++))
  fi
  
  # Check Go version files
  local go_version_files=(
    "$RINNA_DIR/api/pkg/health/version.go"
    "$RINNA_DIR/api/internal/version/version.go"
  )
  
  for version_file in "${go_version_files[@]}"; do
    if [ -f "$version_file" ]; then
      local go_version=$(grep -o 'Version\s*=\s*"[^"]*"' "$version_file" | sed -E 's/.*"([^"]*)".*$/\1/')
      if [[ -z "$go_version" ]]; then
        # Try again with different formatting
        go_version=$(grep -o 'Version.*"[^"]*"' "$version_file" | sed -E 's/.*"([^"]*)".*$/\1/')
      fi
      if [[ "$go_version" != "$root_version" ]]; then
        echo -e "${RED}Go version mismatch in ${version_file}: ${go_version} (should be ${root_version})${NC}"
        ((inconsistencies++))
      fi
    fi
  done
  
  # Report result
  if [[ $inconsistencies -eq 0 ]]; then
    print_success "All versions are consistent!"
    return 0
  else
    echo -e "${RED}Found ${inconsistencies} version inconsistencies!${NC}"
    return 1
  fi
}

create_git_tag() {
  local version="$1" message="$2"
  local tag_name="v${version}"
  
  if [[ -z "$message" ]]; then
    message="Release version ${version}"
  fi
  
  git tag -a "$tag_name" -m "$message"
  print_success "Created git tag: ${tag_name}"
}

# Command Functions
cmd_current() {
  local current_version=$(get_version)
  IFS='.' read -r major minor patch <<< "$current_version"
  
  # Get other properties
  local last_updated=$(get_property "lastUpdated")
  local release_type=$(get_property "releaseType")
  local build_number=$(get_property "buildNumber")
  
  print_header "Current version information:"
  echo -e "  Version: ${GREEN}${current_version}${NC}"
  echo -e "  Major: ${major}, Minor: ${minor}, Patch: ${patch}"
  echo -e "  Last Updated: ${last_updated}"
  echo -e "  Release Type: ${release_type}"
  echo -e "  Build Number: ${build_number}"
  
  # Check git tag
  if git tag -l "v${current_version}" | grep -q "v${current_version}"; then
    echo -e "  Git tag: ${GREEN}v${current_version}${NC} exists"
  else
    echo -e "  Git tag: ${YELLOW}v${current_version}${NC} does not exist"
  fi
  
  # Check GitHub release
  if command -v gh &> /dev/null && gh release view "v${current_version}" &> /dev/null; then
    echo -e "  GitHub release: ${GREEN}v${current_version}${NC} exists"
  else
    echo -e "  GitHub release: ${YELLOW}v${current_version}${NC} does not exist"
  fi
  
  # Show release eligibility
  if should_create_github_release "$current_version" "$release_type"; then
    echo -e "  GitHub release: ${BLUE}Eligible for GitHub release${NC}"
  else
    echo -e "  GitHub release: ${YELLOW}Not eligible for GitHub release${NC} (minor patch or SNAPSHOT)"
  fi
  
  verify_consistency
}

cmd_verify() {
  verify_consistency
}

cmd_update() {
  local current_version=$(get_version)
  
  print_header "Updating all files to match version.properties (${current_version})"
  update_pom_versions "$current_version"
  update_readme_version "$current_version"
  update_go_version "$current_version"
  
  git add "$RINNA_DIR/pom.xml" $(find "$RINNA_DIR" -name "pom.xml" | grep -v "$RINNA_DIR/pom.xml") "$README_FILE" "$RINNA_DIR/api/pkg/health/version.go" "$RINNA_DIR/api/internal/version/version.go"
  git commit -m "Sync version files with version.properties (${current_version})"
  print_success "Committed version changes"
  
  verify_consistency
}

cmd_bump_version() {
  local index="$1" message="$2"
  local current_version=$(get_version)
  local new_version=$(increment_version "$current_version" "$index")
  
  print_header "Bumping version: ${current_version} → ${GREEN}${new_version}${NC}"
  
  update_version_properties "$new_version"
  update_pom_versions "$new_version"
  update_readme_version "$new_version"
  update_go_version "$new_version"
  
  # Generate architecture diagrams for major or minor version bumps
  if [[ "$index" -eq 0 || "$index" -eq 1 ]]; then
    if [[ -x "$RINNA_DIR/bin/rin-diagrams" ]]; then
      print_header "Generating updated architecture diagrams for ${new_version}..."
      "$RINNA_DIR/bin/rin-diagrams" --force || print_warning "Failed to generate architecture diagrams"
      
      # Add new diagrams to git if they were created
      if [[ -d "$RINNA_DIR/docs/architecture/diagrams" ]]; then
        git add "$RINNA_DIR/docs/architecture"
      fi
    else
      print_warning "rin-diagrams not found or not executable, skipping architecture diagram generation"
    fi
  fi
  
  git add "$VERSION_FILE" "$RINNA_DIR/pom.xml" $(find "$RINNA_DIR" -name "pom.xml" | grep -v "$RINNA_DIR/pom.xml") "$README_FILE" "$RINNA_DIR/api/pkg/health/version.go" "$RINNA_DIR/api/internal/version/version.go"
  git commit -m "Bump version to ${new_version}"
  print_success "Committed version change"
  
  if [[ -n "$message" ]]; then
    create_git_tag "$new_version" "$message"
  fi
  
  verify_consistency
  
  return 0
}

cmd_set() {
  local new_version="$1" message="$2"
  
  if [[ ! "$new_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    print_error "Invalid version format. Must be in format: X.Y.Z"
  fi
  
  local current_version=$(get_version)
  print_header "Setting version: ${current_version} → ${GREEN}${new_version}${NC}"
  
  update_version_properties "$new_version"
  update_pom_versions "$new_version"
  update_readme_version "$new_version"
  update_go_version "$new_version"
  
  # Generate architecture diagrams for major version changes or when changing to x.0.0 versions
  if [[ "${new_version%.*}" != "${current_version%.*}" ]] || [[ "${new_version}" =~ ^[0-9]+\.0\.0$ ]]; then
    if [[ -x "$RINNA_DIR/bin/rin-diagrams" ]]; then
      print_header "Generating updated architecture diagrams for ${new_version}..."
      "$RINNA_DIR/bin/rin-diagrams" --force || print_warning "Failed to generate architecture diagrams"
      
      # Add new diagrams to git if they were created
      if [[ -d "$RINNA_DIR/docs/architecture/diagrams" ]]; then
        git add "$RINNA_DIR/docs/architecture"
      fi
    else
      print_warning "rin-diagrams not found or not executable, skipping architecture diagram generation"
    fi
  fi
  
  git add "$VERSION_FILE" "$RINNA_DIR/pom.xml" $(find "$RINNA_DIR" -name "pom.xml" | grep -v "$RINNA_DIR/pom.xml") "$README_FILE" "$RINNA_DIR/api/pkg/health/version.go" "$RINNA_DIR/api/internal/version/version.go"
  git commit -m "Set version to ${new_version}"
  print_success "Committed version change"
  
  if [[ -n "$message" ]]; then
    create_git_tag "$new_version" "$message"
  fi
  
  verify_consistency
}

cmd_release() {
  local current_version=$(get_version) message="$1" force_github="$2"
  
  verify_consistency || print_error "Cannot create release due to version inconsistencies"
  
  if [[ -z "$message" ]]; then
    message="Release version ${current_version}"
  fi
  
  print_header "Creating release for version: ${GREEN}${current_version}${NC}"
  
  # Check if there are uncommitted changes
  if ! git diff --quiet || ! git diff --cached --quiet; then
    print_warning "Uncommitted changes detected in repository"
    # Ask user what to do
    echo -e "Select an action:"
    echo -e "  1) Stash changes temporarily (recommended)"
    echo -e "  2) Continue without committing release type change"
    echo -e "  3) Abort release process"
    read -p "Enter option (1-3): " choice
    
    case "$choice" in
      1)
        # Stash changes
        print_header "Stashing changes temporarily"
        git stash push -m "Stashed changes before release ${current_version}"
        
        # Update release type if needed
        local current_release_type=$(get_property "releaseType")
        if [[ "$current_release_type" != "RELEASE" ]]; then
          sed -i "s/^releaseType=.*/releaseType=RELEASE/" "$VERSION_FILE"
          git add "$VERSION_FILE"
          if ! git commit -m "Update release type for version ${current_version}"; then
            git stash pop
            print_error "Failed to commit release type change"
          fi
          print_success "Updated release type to RELEASE"
        else
          print_warning "Release type is already set to RELEASE, skipping update"
        fi
        
        # Flag to pop stash at the end
        local pop_stash=true
        ;;
      2)
        # Skip commit
        print_warning "Skipping release type commit"
        local current_release_type=$(get_property "releaseType")
        if [[ "$current_release_type" != "RELEASE" ]]; then
          sed -i "s/^releaseType=.*/releaseType=RELEASE/" "$VERSION_FILE"
          print_success "Updated release type to RELEASE (not committed)"
        else
          print_warning "Release type is already set to RELEASE, no change needed"
        fi
        local skip_commit=true
        ;;
      3)
        # Abort
        print_error "Release process aborted by user"
        ;;
      *)
        print_error "Invalid option"
        ;;
    esac
  else
    # Normal process when there are no uncommitted changes
    local current_release_type=$(get_property "releaseType")
    if [[ "$current_release_type" != "RELEASE" ]]; then
      sed -i "s/^releaseType=.*/releaseType=RELEASE/" "$VERSION_FILE"
      git add "$VERSION_FILE"
      git commit -m "Update release type for version ${current_version}"
      print_success "Updated release type to RELEASE"
    else
      print_warning "Release type is already set to RELEASE, skipping update"
    fi
  fi
  
  # Create git tag if it doesn't exist
  if ! git tag -l "v${current_version}" | grep -q "v${current_version}"; then
    create_git_tag "$current_version" "$message"
  else
    echo -e "${YELLOW}Git tag v${current_version} already exists${NC}"
  fi
  
  # Determine if this version should have a GitHub release
  local create_gh_release="$force_github"
  if [[ "$create_gh_release" != "true" ]]; then
    if should_create_github_release "$current_version" "RELEASE"; then
      create_gh_release="true"
      print_header "Version ${current_version} qualifies for a GitHub release"
    else
      print_warning "Version ${current_version} does not qualify for automatic GitHub release"
      
      # Ask if user wants to create one anyway
      read -p "Create GitHub release anyway? [y/N] " -r
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        create_gh_release="true"
      fi
    fi
  fi
  
  # Create GitHub release if appropriate
  if [[ "$create_gh_release" == "true" ]] && command -v gh &> /dev/null; then
    # Collect release notes
    local notes=""
    if [[ -f "CHANGELOG.md" ]]; then
      # Try to extract this version's notes from CHANGELOG
      local changelog_section=$(sed -n "/## \[${current_version}\]/,/## \[/p" CHANGELOG.md | sed '$d')
      if [[ -n "$changelog_section" ]]; then
        notes="$changelog_section"
      fi
    fi
    
    # If no notes from changelog, generate from commits
    if [[ -z "$notes" ]]; then
      # Find the previous tag to compare against
      local prev_tag=$(git describe --abbrev=0 --tags "v${current_version}^" 2>/dev/null || echo "")
      if [[ -n "$prev_tag" ]]; then
        notes="## Changes since ${prev_tag}\n\n$(git log --pretty=format:"* %s" ${prev_tag}..v${current_version})"
      else
        notes="$message"
      fi
    fi
    
    # Create the GitHub release
    if echo -e "$notes" | gh release create "v${current_version}" -t "Rinna ${current_version}" -F -; then
      print_success "Created GitHub release: v${current_version}"
    else
      print_error "Failed to create GitHub release"
    fi
  elif [[ "$create_gh_release" == "true" ]]; then
    print_warning "GitHub CLI not installed. Cannot create GitHub release."
  fi
  
  # Restore stashed changes if needed
  if [[ "$pop_stash" == "true" ]]; then
    print_header "Restoring stashed changes"
    if ! git stash pop; then
      print_warning "There might be conflicts from stash pop. Please resolve them manually."
    fi
  fi
  
  # If we skipped the commit, remind user
  if [[ "$skip_commit" == "true" ]]; then
    print_warning "Remember: Release type in $VERSION_FILE was changed but not committed"
    print_warning "You may want to commit this change manually later"
  fi
}

cmd_tag() {
  local current_version=$(get_version) message="$1"
  
  verify_consistency || print_error "Cannot create tag due to version inconsistencies"
  
  if [[ -z "$message" ]]; then
    message="Version ${current_version}"
  fi
  
  print_header "Creating git tag for version: ${GREEN}${current_version}${NC}"
  create_git_tag "$current_version" "$message"
}

# Display help
show_help() {
  cat << EOF
${BLUE}rin-version${NC} - Rinna version management utility

Usage: rin-version [command] [options]

Commands:
  current                 Show current version information
  major                   Bump major version (x.0.0)
  minor                   Bump minor version (0.x.0)
  patch                   Bump patch version (0.0.x)
  set <version>           Set to specific version (e.g., 1.2.3)
  release                 Create a release from current version
  tag                     Create a git tag for current version
  verify                  Verify version consistency across files
  update                  Update all files to match version.properties

Options:
  -m, --message <msg>     Custom release/commit message
  -g, --github            Force GitHub release creation (regardless of version type)
  -h, --help              Show this help message

Release Behavior:
  - Git tags are created for ALL version changes
  - GitHub releases are automatically created for:
    • Major versions (x.0.0)
    • Minor versions (0.x.0) 
    • Significant patch versions (based on commit message)
    • Versions explicitly marked as RELEASE type
  - For other patch versions, you'll be prompted to create a GitHub release
  - Use --github to force GitHub release creation for any version
  - If uncommitted changes exist when creating a release, you'll be prompted to:
    • Stash changes temporarily (recommended)
    • Continue without committing release type change
    • Abort the release process

Examples:
  rin-version current     # Show current version information
  rin-version patch       # Bump patch version
  rin-version set 2.0.0   # Set version to 2.0.0
  rin-version release -g  # Force GitHub release creation
EOF
}

# Parse arguments
COMMAND=""
VERSION=""
MESSAGE=""
FORCE_GITHUB="false"

while [[ $# -gt 0 ]]; do
  case $1 in
    current|major|minor|patch|release|tag|verify|update)
      COMMAND="$1"
      shift
      ;;
    set)
      COMMAND="set"
      if [[ $# -gt 1 && ! "$2" =~ ^- ]]; then
        VERSION="$2"
        shift
      else
        print_error "Version must be provided after 'set' command"
      fi
      shift
      ;;
    -m|--message)
      if [[ $# -gt 1 && ! "$2" =~ ^- ]]; then
        MESSAGE="$2"
        shift
      else
        print_error "Message must be provided after -m/--message"
      fi
      shift
      ;;
    -g|--github)
      FORCE_GITHUB="true"
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      print_error "Unknown option or command: $1"
      ;;
  esac
done

# Ensure version.properties exists
if [[ ! -f "$VERSION_FILE" ]]; then
  current_version=$(grep -m 1 "<version>" "$RINNA_DIR/pom.xml" | sed -E 's/.*<version>(.*)<\/version>.*/\1/')
  print_warning "version.properties not found, creating with version $current_version"
  cat > "$VERSION_FILE" << EOF
version=$current_version
lastUpdated=$(date +%Y-%m-%d)
releaseType=SNAPSHOT
buildNumber=1
EOF
fi

# Process command
case "$COMMAND" in
  current)
    cmd_current
    ;;
  verify)
    cmd_verify
    ;;
  update)
    cmd_update
    ;;
  major)
    cmd_bump_version 0 "$MESSAGE"
    ;;
  minor)
    cmd_bump_version 1 "$MESSAGE"
    ;;
  patch)
    cmd_bump_version 2 "$MESSAGE"
    ;;
  set)
    cmd_set "$VERSION" "$MESSAGE"
    ;;
  release)
    cmd_release "$MESSAGE" "$FORCE_GITHUB"
    ;;
  tag)
    cmd_tag "$MESSAGE"
    ;;
  *)
    print_error "No command specified"
    ;;
esac