/*
 * Unified configuration for the Rinna workflow management system
 *
 * Copyright (c) 2025 Eric C. Mumford (@heymumford)
 * This file is subject to the terms and conditions defined in
 * the LICENSE file, which is part of this source code package.
 */

package org.rinna.config;

// FileInputStream replaced with Files.newInputStream
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Unified configuration for the Rinna system.
 * <p>
 * This class provides access to configuration values from the centralized
 * configuration system. It loads configuration from the following sources
 * in order of precedence:
 * <ol>
 *   <li>Environment variables with RINNA_ prefix</li>
 *   <li>Java properties file generated by rin-config</li>
 *   <li>Default values defined in code</li>
 * </ol>
 * <p>
 * Configuration is loaded lazily when first accessed and cached.
 */
public final class RinnaConfig {
    private static final Logger LOGGER = LoggerFactory.getLogger(RinnaConfig.class);
    
    private static final String ENV_VAR_PREFIX = "RINNA_";
    private static final String CONFIG_DIR_ENV = ENV_VAR_PREFIX + "PROJECT_CONFIG_DIR";
    private static final String DEFAULT_CONFIG_DIR = System.getProperty("user.home") + "/.rinna/config";
    private static final String JAVA_CONFIG_PATH = "/java/rinna.properties";
    
    private static RinnaConfig instance;
    private final Properties properties = new Properties();
    private final Map<String, String> cache = new ConcurrentHashMap<>();
    
    private RinnaConfig() {
        loadConfiguration();
    }
    
    /**
     * Gets the singleton instance of the configuration.
     *
     * @return the configuration instance
     */
    public static RinnaConfig getInstance() {
        synchronized (RinnaConfig.class) {
        if (instance == null) {
            instance = new RinnaConfig();
        }
        }
        return instance;
    }
    
    /**
     * Reloads the configuration from all sources.
     * Useful for testing or after configuration changes.
     */
    public void reload() {
        properties.clear();
        cache.clear();
        loadConfiguration();
    }
    
    /**
     * Gets a configuration value as a string.
     *
     * @param key the configuration key
     * @return the configuration value, or null if not found
     */
    public String getString(String key) {
        return getString(key, null);
    }
    
    /**
     * Gets a configuration value as a string.
     *
     * @param key the configuration key
     * @param defaultValue the default value to return if the key is not found
     * @return the configuration value, or the default value if not found
     */
    public String getString(String key, String defaultValue) {
        return cache.computeIfAbsent(key, k -> {
            // First check environment variables
            String envKey = toEnvVarName(k);
            String value = System.getenv(envKey);
            
            // Then check properties
            if (value == null) {
                value = properties.getProperty(k);
            }
            
            // Finally use default
            return value != null ? value : defaultValue;
        });
    }
    
    /**
     * Gets a configuration value as an integer.
     *
     * @param key the configuration key
     * @param defaultValue the default value to return if the key is not found or not a valid integer
     * @return the configuration value, or the default value if not found or not a valid integer
     */
    public int getInt(String key, int defaultValue) {
        String value = getString(key);
        if (value == null) {
            return defaultValue;
        }
        
        try {
            return Integer.parseInt(value);
        } catch (NumberFormatException e) {
            LOGGER.warn("Invalid integer value for key {}: {}", key, value);
            return defaultValue;
        }
    }
    
    /**
     * Gets a configuration value as a boolean.
     *
     * @param key the configuration key
     * @param defaultValue the default value to return if the key is not found
     * @return the configuration value, or the default value if not found
     */
    public boolean getBoolean(String key, boolean defaultValue) {
        String value = getString(key);
        if (value == null) {
            return defaultValue;
        }
        
        return Boolean.parseBoolean(value);
    }
    
    /**
     * Gets a configuration value as a long.
     *
     * @param key the configuration key
     * @param defaultValue the default value to return if the key is not found or not a valid long
     * @return the configuration value, or the default value if not found or not a valid long
     */
    public long getLong(String key, long defaultValue) {
        String value = getString(key);
        if (value == null) {
            return defaultValue;
        }
        
        try {
            return Long.parseLong(value);
        } catch (NumberFormatException e) {
            LOGGER.warn("Invalid long value for key {}: {}", key, value);
            return defaultValue;
        }
    }
    
    /**
     * Gets a configuration value as a double.
     *
     * @param key the configuration key
     * @param defaultValue the default value to return if the key is not found or not a valid double
     * @return the configuration value, or the default value if not found or not a valid double
     */
    public double getDouble(String key, double defaultValue) {
        String value = getString(key);
        if (value == null) {
            return defaultValue;
        }
        
        try {
            return Double.parseDouble(value);
        } catch (NumberFormatException e) {
            LOGGER.warn("Invalid double value for key {}: {}", key, value);
            return defaultValue;
        }
    }
    
    /**
     * Checks if a configuration key exists.
     *
     * @param key the configuration key
     * @return true if the key exists, false otherwise
     */
    public boolean hasKey(String key) {
        // Check environment variables
        String envKey = toEnvVarName(key);
        return System.getenv(envKey) != null || properties.containsKey(key);
    }
    
    /**
     * Loads the configuration from all sources.
     */
    private void loadConfiguration() {
        // Get the config directory from environment or default
        String configDir = System.getenv(CONFIG_DIR_ENV);
        if (configDir == null) {
            configDir = DEFAULT_CONFIG_DIR;
        }
        
        Path javaConfigPath = Paths.get(configDir + JAVA_CONFIG_PATH);
        
        // Load from properties file if it exists
        if (Files.exists(javaConfigPath)) {
            try (java.io.InputStream fis = Files.newInputStream(javaConfigPath)) {
                properties.load(fis);
                LOGGER.info("Loaded configuration from {}", javaConfigPath);
            } catch (IOException e) {
                LOGGER.warn("Failed to load configuration from {}", javaConfigPath, e);
            }
        } else {
            LOGGER.warn("Java configuration file not found: {}", javaConfigPath);
            LOGGER.warn("Create with: rin config generate");
        }
    }
    
    /**
     * Converts a dotted path configuration key to an environment variable name.
     * For example, "java.backend.port" becomes "RINNA_JAVA_BACKEND_PORT".
     *
     * @param key the configuration key
     * @return the environment variable name
     */
    private String toEnvVarName(String key) {
        return ENV_VAR_PREFIX + key.replace('.', '_').toUpperCase();
    }
}