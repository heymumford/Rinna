package org.rinna.pui.cli;

import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Utility class for generating shell scripts from PUI operations.
 * Implements SUSBS script generation requirement for PUI components.
 */
public class CommandGenerator {
    
    private final ShellCommandBridge commandBridge;
    private final List<Map.Entry<String, Map<String, String>>> operations = new ArrayList<>();
    private String scriptHeader = "#!/bin/bash\n\n# Generated by Rinna PUI\n# ${date}\n\n";
    private String scriptFooter = "\n# End of script\n";
    
    /**
     * Create a new command generator.
     * 
     * @param commandBridge The command bridge to use for generating commands
     */
    public CommandGenerator(ShellCommandBridge commandBridge) {
        this.commandBridge = commandBridge;
    }
    
    /**
     * Add an operation to the script.
     * 
     * @param operation The operation identifier
     * @param params Map of parameters for the operation
     * @return This instance for method chaining
     */
    public CommandGenerator addOperation(String operation, Map<String, String> params) {
        operations.add(Map.entry(operation, new LinkedHashMap<>(params)));
        return this;
    }
    
    /**
     * Add a comment to the script.
     * 
     * @param comment The comment text
     * @return This instance for method chaining
     */
    public CommandGenerator addComment(String comment) {
        Map<String, String> commentParams = new LinkedHashMap<>();
        commentParams.put("comment", comment);
        operations.add(Map.entry("comment", commentParams));
        return this;
    }
    
    /**
     * Add a blank line to the script.
     * 
     * @return This instance for method chaining
     */
    public CommandGenerator addBlankLine() {
        Map<String, String> params = new LinkedHashMap<>();
        operations.add(Map.entry("blank", params));
        return this;
    }
    
    /**
     * Set a custom script header.
     * 
     * @param header The custom header template
     * @return This instance for method chaining
     */
    public CommandGenerator setScriptHeader(String header) {
        this.scriptHeader = header;
        return this;
    }
    
    /**
     * Set a custom script footer.
     * 
     * @param footer The custom footer template
     * @return This instance for method chaining
     */
    public CommandGenerator setScriptFooter(String footer) {
        this.scriptFooter = footer;
        return this;
    }
    
    /**
     * Generate the shell script content.
     * 
     * @return The shell script as a string
     */
    public String generateScript() {
        StringBuilder script = new StringBuilder();
        
        // Add header with date
        String formattedHeader = scriptHeader.replace("${date}", 
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
        script.append(formattedHeader);
        
        // Add operations
        for (Map.Entry<String, Map<String, String>> entry : operations) {
            String operation = entry.getKey();
            Map<String, String> params = entry.getValue();
            
            switch (operation) {
                case "comment":
                    script.append("# ").append(params.get("comment")).append("\n");
                    break;
                case "blank":
                    script.append("\n");
                    break;
                default:
                    try {
                        String command = commandBridge.generateCommand(operation, params);
                        script.append(command).append("\n");
                    } catch (IllegalArgumentException e) {
                        script.append("# Unsupported operation: ").append(operation).append("\n");
                    }
                    break;
            }
        }
        
        // Add footer
        script.append(scriptFooter);
        
        return script.toString();
    }
    
    /**
     * Save the generated script to a file.
     * 
     * @param filePath The path to save the script to
     * @throws IOException If an I/O error occurs
     */
    public void saveScript(String filePath) throws IOException {
        String script = generateScript();
        
        try (FileWriter writer = new FileWriter(filePath)) {
            writer.write(script);
        }
        
        // Make the file executable
        try {
            ProcessBuilder pb = new ProcessBuilder("chmod", "+x", filePath);
            pb.start().waitFor();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IOException("Failed to make script executable", e);
        }
    }
    
    /**
     * Clear all operations from the generator.
     * 
     * @return This instance for method chaining
     */
    public CommandGenerator clear() {
        operations.clear();
        return this;
    }
    
    /**
     * Get the current operations list.
     * 
     * @return List of operations
     */
    public List<Map.Entry<String, Map<String, String>>> getOperations() {
        return new ArrayList<>(operations);
    }
    
    /**
     * Record a macro (sequence of operations) from user operations.
     * 
     * @param name The macro name
     * @return Generated macro script
     */
    public String recordMacro(String name) {
        StringBuilder macro = new StringBuilder();
        
        // Add macro header
        macro.append("#!/bin/bash\n\n");
        macro.append("# Rinna Macro: ").append(name).append("\n");
        macro.append("# Generated: ").append(LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("\n\n");
        
        // Add function definition
        macro.append("function ").append(name.replaceAll("[^a-zA-Z0-9_]", "_")).append("() {\n");
        
        // Add operations
        for (Map.Entry<String, Map<String, String>> entry : operations) {
            String operation = entry.getKey();
            Map<String, String> params = entry.getValue();
            
            if (operation.equals("comment")) {
                macro.append("  # ").append(params.get("comment")).append("\n");
            } else if (operation.equals("blank")) {
                macro.append("\n");
            } else {
                try {
                    String command = commandBridge.generateCommand(operation, params);
                    macro.append("  ").append(command).append("\n");
                } catch (IllegalArgumentException e) {
                    macro.append("  # Unsupported operation: ").append(operation).append("\n");
                }
            }
        }
        
        // Close function
        macro.append("}\n\n");
        
        // Add usage example
        macro.append("# Usage: ").append(name.replaceAll("[^a-zA-Z0-9_]", "_")).append(" [arguments]\n");
        
        return macro.toString();
    }
    
    /**
     * Generate a shell alias for a PUI operation.
     * 
     * @param operation The operation identifier
     * @param params Map of parameters for the operation
     * @return Shell alias definition
     */
    public String generateAlias(String aliasName, String operation, Map<String, String> params) {
        try {
            String command = commandBridge.generateCommand(operation, params);
            return "alias " + aliasName + "='" + command + "'";
        } catch (IllegalArgumentException e) {
            return "# Unsupported operation for alias: " + operation;
        }
    }
}